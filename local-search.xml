<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux——Linux基本操作（二）</title>
    <link href="/2022/07/18/Linux%E2%80%94%E2%80%94Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/07/18/Linux%E2%80%94%E2%80%94Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="linuxlinux基本操作二">Linux——Linux基本操作（二）</h1><h2 id="vim编辑器">vim编辑器</h2><p>Linux系统都会自带vi编辑器，但是vi编辑器太难用了！所以建议大家安装vim编辑器，安装命令：sudoapt-get install vim</p><p>vi xxx 使用vi编辑器打开文件。</p><h3 id="vim编辑器三种工作模式">vim编辑器三种工作模式</h3><ul><li><p>一般模式(指令模式)：默认模式，用vi打开一个软件以后自动进入到此模式。</p></li><li><p>编辑模式：一般模式中无法编辑文件，要编辑文件就要进入编辑模式，按下“i、I、a、A、o、O、s、r”等就会进入到编辑模式。一般按下“a”进入编辑模式。按下ESC键可退出编辑模式。</p></li><li><p>命令行模式(底行模式)：先进入到一般模式，然后输入：、/、？这三个中的任意一个就可以进入到命令行模式。输入/xxx，表示在文件中查找xxx；输入:wq来保存退出。:q退出，:q!不保存退出，:w保存。</p></li></ul><h3 id="其他操作方式">其他操作方式</h3><p>按下键盘上的上下左右键来控制光标。</p><p>一般模式下：</p><ul><li>dd，删除光标所在行，ndd，删除光标所在行及其下n行。</li><li>u，撤销，恢复上一步。</li><li>. ,重复前一个操作。</li><li>yy，复制光标所在行</li><li>nyy，复制光标所在向下n行，比如10yy就是复制光标下10行。</li><li>p和P，p为复制到光标下一行，P复制到光标上一行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux——Linux基本操作（一）</title>
    <link href="/2022/07/17/Linux%E2%80%94%E2%80%94Shell%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/17/Linux%E2%80%94%E2%80%94Shell%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="linuxlinux基本操作一">Linux——Linux基本操作（一）</h1><h2 id="常用shell命令">常用Shell命令</h2><ul><li>目录信息查看命令ls</li><li>目录切换命令cd</li><li>当前路径显示命令pwd</li><li>系统信息查看命令uname</li><li>清理屏幕命令clear</li><li>显示文件内容命令cat</li><li>切换用户身份命令sudo</li><li>文件拷贝命令cp</li><li>切换用户命令su</li><li>移动文件命令mv</li><li>创建文件夹命令mkdir</li><li>创建文件命令touch</li><li>删除命令rm</li><li>目录删除命令rmdir</li><li>显示网络配置信息命令ifconfig</li><li>重启命令reboot</li><li>关机命令poweroff</li><li>系统帮助命令man</li><li>数据同步写入磁盘命令sync</li><li>查找文件命令find</li><li>查找内容命令grep</li><li>文件夹大小查看命令du</li><li>磁盘空间检查命令df</li><li>使用gedit打开某个文件命令gedit</li><li>当前的系统进程查看命令ps</li><li>进程实时运行状态查看命令top</li><li>文件类型查看命令file</li></ul><h2 id="软件安装">软件安装</h2><ul><li><p>通过APP Store安装</p><p>使用apt工具安装软件，需要sudo，也就是root权限。</p></li><li><p>使用APT工具安装</p><p>使用apt包管理工具，apt可以自动下载，配置，安装。</p></li><li><p>deb软件包安装</p><p>使用dpkg命令安装deb软件包，命令如下： sudo dpkg -i xxxx.deb在windows下，我们安装的是.exe文件，在Ubuntu就有一个.deb。</p></li><li><p>自己下载程序源码编译安装</p><p>Make Make install</p></li><li><p>其他安装方法</p><p>QT扩展名是.run</p></li></ul><h2 id="文件系统结构">文件系统结构</h2><h3 id="根目录">根目录“/”：</h3><ul><li>Linux下“/”就是根目录！所有的目录都是由根目录衍生出来的。</li></ul><h3 id="文件系统结构-1">文件系统结构</h3><ul><li>/bin：存放二进制可执行文件，这些命令在单用户模式下也能够使用。可以被root和一般的账号使用。</li><li>/boot：Ubuntu内核和启动文件，比如vmlinuz-xxx。gurb引导装载程序。</li><li>/dev：设备驱动文件</li><li>/etc：存放一些系统配置文件，比如用户账号和密码文件，各种服务的起始地址。</li><li>/home：系统默认的用户主文件夹，一般创建用户账户的时候，默认的用户主文件夹都会放到此目录下。</li><li>/lib：存放库文件</li><li>/media：此目录下放置可插拔设备，比如SD卡，或者U盘就是挂载到这个目录中。</li><li>/mnt：用户可使用的挂载点，如果要挂载一些额外的设备，那么就可以挂载到此处。</li><li>/opt：可选的文件和程序存放目录，给第三方软件放置的目录。</li><li>/root：root用户目录，也就是系统管理员目录。</li><li>/sbin：和/bin类似，也是存放一些二进制可执行文件。sbin下面的一般是系统开机过程中所需要的命令。</li><li>/srv：服务相关目录。比如网络服务。</li><li>/sys：记录内核信息，虚拟文件系统。</li><li>/tmp：临时目录</li><li>/var：存放一些变化的文件，比如日志文件</li><li>/usr：usr不是user的缩写，而是UNIX SoftwareResource的缩写，存放于系统用户有关的文件，会占用很大的存储空间！</li><li>/proc：虚拟文件系统，数据放置到内存中，存放系统运行信息</li></ul><h3 id="绝对路径和相对路径">绝对路径和相对路径</h3><ul><li>绝对路径：从根目录“/”算起的路径。</li><li>相对路径：相对于目前路径的文件名写法，比如./home/zzk。不是以“/”开头的就行。</li><li>“.”代表当前路径，也可以 用“./”表示</li><li>“..”代表上一层目录，也可以用“../”表示</li></ul><h2 id="磁盘管理">磁盘管理</h2><h3 id="磁盘文件">磁盘文件</h3><ul><li><p>/dev/sd*文件，此类文件是磁盘设备文件，并不能直接访问磁盘，必须要将磁盘挂载到某一个目录下才可以访问。</p><p>例如：/dev/sdb和/dev/sdb1是U盘的设备文件。</p><p>/dev/sdb表示U盘，/dev/sdb1表示U盘的第一个分区。</p></li></ul><h3 id="磁盘和目录的容量查询命令">磁盘和目录的容量查询命令</h3><ul><li>df：列出文件系统的整体磁盘使用量。主要查看个文件系统的使用量，</li><li>du：评估文件系统的磁盘使用量，主要查看单个文件的大小。</li></ul><h3 id="磁盘挂载与卸载分区和格式化">磁盘挂载与卸载，分区和格式化</h3><ul><li><p>磁盘的挂载和卸载</p><p>mount和umount命令</p></li><li><p>磁盘分区</p><p>fdisk命令</p></li><li><p>磁盘格式化</p><p>磁盘分区创建好以后就可以格式化磁盘，使用命令mkfs。如：mkfs -t vfat/dev/sdx</p></li></ul><h2 id="压缩与解压缩">压缩与解压缩</h2><h3 id="linux下常用的压缩格式">Linux下常用的压缩格式</h3><p>Linux下常用的压缩扩展名有：.tar、.tar.bz2、.tar.gz</p><h3 id="gzip压缩工具">gzip压缩工具</h3><p>.gzip工具负责压缩和解压缩.gz格式的压缩包。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gzip xxx     &#x2F;&#x2F;压缩gzip -d xxx.gz&#x2F;&#x2F;解压缩gzip对文件夹进行压缩gzip -r xxx&#x2F;&#x2F;对文件夹进行压缩gzip -rd xxx.gz&#x2F;&#x2F;对文件夹进行解压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>gzip虽然可以对文件夹进行压缩，但是并不能提供打包的服务，只是对文件夹中的所有文件进行了单独的压缩。</p><h3 id="bzip2压缩工具">bzip2压缩工具</h3><p>和gzip类似，只是bzip2工具负责压缩和解压缩.bz2格式的压缩包。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">bzip2 -z xxx&#x2F;&#x2F;压缩bzip2 -d xxx.gz&#x2F;&#x2F;解压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><h3 id="tar打包工具">tar打包工具</h3><ul><li><p>tar工具参数：</p><p>-f，使用归档文件或 ARCHIVE 设备 -c：创建新归档，创建压缩文件-x：从图档中解出文件，解压缩 -j：使用bzip2压缩格式。-z：使用gzip压缩格式 -v：打印出命令执行过程。</p></li><li><p>tar工具提供打包服务，就是将多个文件打包，比如</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -vcf test.tar test&#x2F;&#x2F;将test打包成test.tartar -vxf test.tar&#x2F;&#x2F;解包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul><p>上面的tar命令只提供了打包和解包的功能，tar在提供打包和解包的同时使用gzip/bzip2进行压缩，实现类似windwos下winRAR软件的命令。</p><ul><li><p>对.tar.bz2进行压缩和解压缩</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -vxjf xxx.tar.bz2    &#x2F;&#x2F;解压缩tar -vcjf xxx.tar.bz2 xxx &#x2F;&#x2F;压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>对.tar.gz进行压缩和解压缩</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -vxzfxxx.tar.gz&#x2F;&#x2F;解压缩tar -vczf xxx.tar.gz xxx &#x2F;&#x2F;压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul><h3 id="其他格式的压缩和解压缩">其他格式的压缩和解压缩</h3><ul><li><p>.rar格式</p><p>需要先安装rar：sudo apt-get install rar</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rar x xxx.rar&#x2F;&#x2F;解压缩rar a xxx.rar xxx&#x2F;&#x2F;压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>.zip格式</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">zip -rv xxx.zip xxx&#x2F;&#x2F;压缩unzip -v xxx.zip&#x2F;&#x2F;解压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux——Linux基本操作（一）</title>
    <link href="/2022/07/16/Linux%E2%80%94%E2%80%94Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/07/16/Linux%E2%80%94%E2%80%94Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="linuxlinux基本操作一">Linux——Linux基本操作（一）</h1><h2 id="常用shell命令">常用Shell命令</h2><ul><li>目录信息查看命令ls</li><li>目录切换命令cd</li><li>当前路径显示命令pwd</li><li>系统信息查看命令uname</li><li>清理屏幕命令clear</li><li>显示文件内容命令cat</li><li>切换用户身份命令sudo</li><li>文件拷贝命令cp</li><li>切换用户命令su</li><li>移动文件命令mv</li><li>创建文件夹命令mkdir</li><li>创建文件命令touch</li><li>删除命令rm</li><li>目录删除命令rmdir</li><li>显示网络配置信息命令ifconfig</li><li>重启命令reboot</li><li>关机命令poweroff</li><li>系统帮助命令man</li><li>数据同步写入磁盘命令sync</li><li>查找文件命令find</li><li>查找内容命令grep</li><li>文件夹大小查看命令du</li><li>磁盘空间检查命令df</li><li>使用gedit打开某个文件命令gedit</li><li>当前的系统进程查看命令ps</li><li>进程实时运行状态查看命令top</li><li>文件类型查看命令file</li></ul><h2 id="软件安装">软件安装</h2><ul><li><p>通过APP Store安装</p><p>使用apt工具安装软件，需要sudo，也就是root权限。</p></li><li><p>使用APT工具安装</p><p>使用apt包管理工具，apt可以自动下载，配置，安装。</p></li><li><p>deb软件包安装</p><p>使用dpkg命令安装deb软件包，命令如下： sudo dpkg -i xxxx.deb在windows下，我们安装的是.exe文件，在Ubuntu就有一个.deb。</p></li><li><p>自己下载程序源码编译安装</p><p>Make Make install</p></li><li><p>其他安装方法</p><p>QT扩展名是.run</p></li></ul><h2 id="文件系统结构">文件系统结构</h2><h3 id="根目录">根目录“/”：</h3><ul><li>Linux下“/”就是根目录！所有的目录都是由根目录衍生出来的。</li></ul><h3 id="文件系统结构-1">文件系统结构</h3><ul><li>/bin：存放二进制可执行文件，这些命令在单用户模式下也能够使用。可以被root和一般的账号使用。</li><li>/boot：Ubuntu内核和启动文件，比如vmlinuz-xxx。gurb引导装载程序。</li><li>/dev：设备驱动文件</li><li>/etc：存放一些系统配置文件，比如用户账号和密码文件，各种服务的起始地址。</li><li>/home：系统默认的用户主文件夹，一般创建用户账户的时候，默认的用户主文件夹都会放到此目录下。</li><li>/lib：存放库文件</li><li>/media：此目录下放置可插拔设备，比如SD卡，或者U盘就是挂载到这个目录中。</li><li>/mnt：用户可使用的挂载点，如果要挂载一些额外的设备，那么就可以挂载到此处。</li><li>/opt：可选的文件和程序存放目录，给第三方软件放置的目录。</li><li>/root：root用户目录，也就是系统管理员目录。</li><li>/sbin：和/bin类似，也是存放一些二进制可执行文件。sbin下面的一般是系统开机过程中所需要的命令。</li><li>/srv：服务相关目录。比如网络服务。</li><li>/sys：记录内核信息，虚拟文件系统。</li><li>/tmp：临时目录</li><li>/var：存放一些变化的文件，比如日志文件</li><li>/usr：usr不是user的缩写，而是UNIX SoftwareResource的缩写，存放于系统用户有关的文件，会占用很大的存储空间！</li><li>/proc：虚拟文件系统，数据放置到内存中，存放系统运行信息</li></ul><h3 id="绝对路径和相对路径">绝对路径和相对路径</h3><ul><li>绝对路径：从根目录“/”算起的路径。</li><li>相对路径：相对于目前路径的文件名写法，比如./home/zzk。不是以“/”开头的就行。</li><li>“.”代表当前路径，也可以 用“./”表示</li><li>“..”代表上一层目录，也可以用“../”表示</li></ul><h2 id="磁盘管理">磁盘管理</h2><h3 id="磁盘文件">磁盘文件</h3><ul><li><p>/dev/sd*文件，此类文件是磁盘设备文件，并不能直接访问磁盘，必须要将磁盘挂载到某一个目录下才可以访问。</p><p>例如：/dev/sdb和/dev/sdb1是U盘的设备文件。</p><p>/dev/sdb表示U盘，/dev/sdb1表示U盘的第一个分区。</p></li></ul><h3 id="磁盘和目录的容量查询命令">磁盘和目录的容量查询命令</h3><ul><li>df：列出文件系统的整体磁盘使用量。主要查看个文件系统的使用量，</li><li>du：评估文件系统的磁盘使用量，主要查看单个文件的大小。</li></ul><h3 id="磁盘挂载与卸载分区和格式化">磁盘挂载与卸载，分区和格式化</h3><ul><li><p>磁盘的挂载和卸载</p><p>mount和umount命令</p></li><li><p>磁盘分区</p><p>fdisk命令</p></li><li><p>磁盘格式化</p><p>磁盘分区创建好以后就可以格式化磁盘，使用命令mkfs。如：mkfs -t vfat/dev/sdx</p></li></ul><h2 id="压缩与解压缩">压缩与解压缩</h2><p>Linux下常用的压缩扩展名有：.tar、.tar.bz2、.tar.gz。</p><h3 id="gzip压缩工具">gzip压缩工具</h3><ul><li><p>.gzip工具负责压缩和解压缩.gz格式的压缩包。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gzip xxx&#x2F;&#x2F;压缩gzip -d xxx.gz&#x2F;&#x2F;解压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>gzip对文件夹进行压缩</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gzip -r xxx&#x2F;&#x2F;对文件夹进行压缩gzip -rd xxx.gz&#x2F;&#x2F;对文件夹进行解压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul><p>gzip虽然可以对文件夹进行压缩，但是并不能提供打包的服务，只是对文件夹中的所有文件进行了单独的压缩。</p><h3 id="bzip2压缩工具">bzip2压缩工具</h3><p>和gzip类似，只是bzip2工具负责压缩和解压缩.bz2格式的压缩包。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">bzip2 -z xxx&#x2F;&#x2F;压缩bzip2 -d xxx.gz&#x2F;&#x2F;解压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><h3 id="tar打包工具">tar打包工具</h3><p>tar工具参数：</p><ul><li>-f，使用归档文件或 ARCHIVE 设备</li><li>-c：创建新归档，创建压缩文件</li><li>-x：从图档中解出文件，解压缩</li><li>-j：使用bzip2压缩格式。</li><li>-z：使用gzip压缩格式</li><li>-v：打印出命令执行过程。</li></ul><p>tar工具提供打包服务，就是将多个文件打包，比如</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -vcf test.tar test&#x2F;&#x2F;将test打包成test.tartar -vxf test.tar&#x2F;&#x2F;解包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>上面的tar命令只提供了打包和解包的功能，tar在提供打包和解包的同时使用gzip/bzip2进行压缩，实现类似windwos下winRAR软件的命令。</p><ul><li><p>对.tar.bz2进行压缩和解压缩</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -vxjf xxx.tar.bz2解压缩tar -vcjf xxx.tar.bz2 xxx 压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>对.tar.gz进行压缩和解压缩</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -vxzfxxx.tar.gz&#x2F;&#x2F;解压缩tar -vczf xxx.tar.gz xxx &#x2F;&#x2F;压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul><h3 id="其他格式的压缩和解压缩">其他格式的压缩和解压缩</h3><ul><li><p>.rar格式</p><p>需要先安装rar：sudo apt-get install rar</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rar x xxx.rar&#x2F;&#x2F;解压缩rar a xxx.rar xxx&#x2F;&#x2F;压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>.zip格式</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">zip -rv xxx.zip xxx&#x2F;&#x2F;压缩unzip -v xxx.zip&#x2F;&#x2F;解压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ul><h2 id="用户与用户组">用户与用户组</h2><h3 id="linux用户">Linux用户</h3><p>Linux是一个多用户操作系统，不同的用户拥有不同的权限。可以查看和操作不同的文件。Ubuntu有三种用户：初次创建的用户、root用户、普通用户。</p><p>​ Linux用户记录在/etc/passwd这个文件内。 ​Linux用户密码记录在/etc/shadow这个文件内。 ​每个用户都有一个ID，叫做UID。</p><h3 id="linux用户组">Linux用户组</h3><p>用户和用户组的存在就是为了控制文件的访问权限，每个用户可以属于多个不同的组，每个用户组都有一个ID，叫做GID。<strong>用户组信息存储在/etc/group文件中。</strong></p><h3 id="创建用户和用户组">创建用户和用户组</h3><p>​ 添加用户：adduser命令，adduser 用户名 ​用户查询：finger命令，finger 用户名 ​ 修改用户密码：passwd命令，passwd用户名 ​ 删除用户：deluser命令，deluser 用户名 ​添加用户组：addgroup命令，addgroup 用户组名 ​显示组内用户名：groups命令，groups 用户组名 ​删除用户组：delgroup命令，delgroup用户组名</p><h2 id="文件权限管理">文件权限管理</h2><p>文件权限是指不同的用户或用户组对某个文件拥有的权限，文件的权限分为三种：r：读、w：写、x：可执行。可以使用二进制表示文件权限：r=4、w=2、x=1。文件描述形式如下：</p><p><imgsrc="https://gitee.com/math2022xi/mypicgo/raw/master/img/202207172356371.png" /></p><p>第一位表示文件类型，剩下的每三位表示一组权限，分别对应拥有者权限、拥有者所在组权限、其他用户权限。</p><h3 id="文件权限修改">文件权限修改</h3><ul><li><p>修改文件权限命令</p><p>chmod命令</p></li><li><p>修改文件所属用户</p><p>chown命令</p></li></ul><h2 id="文件连接">文件连接</h2><p>Linux有两种连接文件：符号连接(软连接)和硬链接，符号链接类似Windows下的快捷方式。硬链接通过文件系统的inode连接来产生新文件名，而不是产生新文件。</p><p>inode：记录文件属性，一个文件一个inode。inode相当于文件ID，查找文件的时候要先找到inode，然后才能读出文件的内容。</p><h3 id="in命令">in命令</h3><p>ln命令用于创建连接文件：ln [选项] 源文件 目标文件</p><p>选项：-s 创建符号链接(软连接)；-f强制创建连接文件，如果目标存在，那么先删除掉目标文件，然后再建立连接文件。</p><h3 id="硬连接">硬连接</h3><p>硬链接是多个文件都指向同一个inode，硬链接知识点：</p><ul><li>具有相同inode的多个文件互为硬链接文件，创建硬链接相当于文件实体多了入口。</li><li>对于硬链接文件，只有删除了源文件以及对应的所有硬连接文件，文件实体才会被删除。</li><li>根据硬链接文件的特点，我们可以通过给文件创建硬连接的方式来防止文件误删除。</li><li>不论修改源文件还是连接文件，另一个文件的数据都会被改变。</li><li>硬连接不能跨文件系统。</li><li>硬连接不能连接到目录。</li></ul><p>因为以上这些限制，硬链接其实不常用。</p><h3 id="符号连接软连接">符号连接(软连接)</h3><p>符号连接类似Windows下的快捷方式，符号链接也叫做软连接，软连接要用的多。符号连接相当于创建了一个独立的文件，这个文件会让数据读取指向它连接的哪个文件的文件名。软连接的特点：</p><ul><li>可以连接到目录。</li><li>可以跨文件系统。</li><li>删除源文件以后，软连接文件也就“打不开了”。</li><li>符号连接文件通过-&gt;来指示具体的连接文件。</li><li>符号连接要使用绝对路径，否则连接出问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32——MQTT协议</title>
    <link href="/2022/07/04/STM32%E2%80%94%E2%80%94MQTT%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/07/04/STM32%E2%80%94%E2%80%94MQTT%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="stm32mqtt协议">STM32——MQTT协议</h1><p><strong>工作流程：</strong></p><p><img src="https://s2.loli.net/2022/07/04/3Nlin8AvFfjZ7yC.jpg" /></p><h2 id="阿里云报文">阿里云报文</h2><h3 id="种报文概述">14种报文概述</h3><p><img src="https://s2.loli.net/2022/07/04/yHYTeBpLPv5MVX6.jpg" /></p><ul><li><p>固定报头格式</p><p><imgsrc="C:\Users\math2\AppData\Roaming\Typora\typora-user-images\image-20220705165447628.png" /></p></li><li><p>剩余长度</p><p>剩余长度（RemainingLength）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。</p><p><img src="https://s2.loli.net/2022/07/05/ihNRqOUGScXAz67.png" /></p><p>剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个延续位（continuationbit）。剩余长度字段最大4个字节。</p></li></ul><h3 id="报文服务等级">报文服务等级</h3><p><img src="https://s2.loli.net/2022/07/04/tjK8XswLJYN6e74.jpg" /></p><p>QoS值0：不管对方是否收到，最多只分发一次。</p><p>QoS值1：必须收到对方应答，否则将再次分发。</p><p>QoS值2：需要经过对方的两次确认。</p><h3 id="connect-连接服务端">CONNECT – 连接服务端</h3><ul><li><p>固定报头：0x10 ?? （剩余长度值）</p></li><li><p>可变报头（十个字节，固定不变）</p><p>CONNECT报文的可变报头按下列次序包含四个字段：协议名（ProtocolName），协议级别（Protocol Level），连接标志（ConnectFlags）和保持连接（Keep Alive）。</p><ul><li><p>协议名：0x00 04 (0x)MQTT，协议名是表示协议名 MQTT的UTF-8编码的字符串</p></li><li><p>协议级别：0x04</p></li><li><p>连接标志：服务端必须验证CONNECT控制报文的保留标志位（第0位）是否为0，如果不为0必须断开客户端连接。</p><p><imgsrc="https://s2.loli.net/2022/07/06/gije27StYpfrZyo.png" /></p></li><li><p>保持连接：保持连接（KeepAlive）是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔。</p><p><imgsrc="https://s2.loli.net/2022/07/06/BsaHXKY3IGmnhq9.png" /></p></li></ul></li><li><p>有效载荷</p><p><img src="https://s2.loli.net/2022/07/06/4LJrjAfclTyaZpm.png" /></p><ul><li>客户端标识符： <em>|securemode=3,signmethod=hmacsha1| </em>设备名称注意替换</li><li>用户名： <em>&amp;# </em>设备名称 #ProductKey 注意替换<br /></li><li>密码：用DeviceSecret做为秘钥对clientId<em>deviceName</em>productKey#进行hmacsha1加密后的结果*设备名称 #ProductKey 注意替换</li></ul></li></ul><h3 id="connack-确认连接请求">CONNACK – 确认连接请求</h3><ul><li><p>固定报头：0x20 02</p></li><li><p>可变报头：</p><p><img src="https://s2.loli.net/2022/07/06/NfuboV5wgIrEqAj.png" /></p><ul><li><p>连接确认标志：第1个字节是连接确认标志，位7-1是保留位且必须设置为0；第0 (SP)位 是当前会话（SessionPresent）标志。</p></li><li><p>连接返回码：</p><p><imgsrc="https://s2.loli.net/2022/07/06/O64oT5jim2lrERP.png" /></p></li></ul></li></ul><h3 id="disconnect-断开连接">DISCONNECT –断开连接</h3><ul><li>固定报头：0xE0 00</li></ul><h3 id="pingreq-心跳请求">PINGREQ – 心跳请求</h3><ul><li>固定报头：0xC0 00</li></ul><h3 id="pingresp-心跳响应">PINGRESP – 心跳响应</h3><ul><li>固定报头：0xD0 00</li></ul><h3 id="subscribe---订阅主题">SUBSCRIBE - 订阅主题</h3><ul><li><p>固定报头：0x82 ?? （剩余长度值）</p></li><li><p>可变报头：报文标识符（两个字节），确定哪条报文。</p></li><li><p>有效载荷</p><p><img src="https://s2.loli.net/2022/07/06/arB4ch7QCENAUzp.png" /></p><p>主题过滤器（物模型通信Topic）如：/sys/hgerCvFPASO/${deviceName}/thing/service/property/set</p><p><strong>可以发送多对主题过滤器 和 QoS等级字段组合。</strong></p></li></ul><h3 id="suback-订阅确认">SUBACK – 订阅确认</h3><ul><li><p>固定报头：0x90 03 （剩余长度值）</p></li><li><p>可变报头</p><p><imgsrc="https://s2.loli.net/2022/07/06/kS9EGRLKJmAjz7P.png" /></p></li><li><p>有效载荷</p><p>允许的返回码值： 0x00 - 最大QoS 0 0x01 - 成功 – 最大QoS 1 0x02 - 成功– 最大 QoS 2 0x80 - Failure 失败</p></li></ul><h3 id="unsubscribe-取消订阅">UNSUBSCRIBE –取消订阅</h3><ul><li><p>固定报头：0xA2 ?? （剩余长度值）</p></li><li><p>可变报头：报文标识符（两个字节），确定哪条报文。</p></li><li><p>有效载荷</p><p><img src="https://s2.loli.net/2022/07/06/blohOnv63Z2eVWf.png" /></p><p><strong>可以发送多对主题过滤器 ，同时取消订阅。</strong></p></li></ul><h3 id="unsuback-取消订阅确认">UNSUBACK – 取消订阅确认</h3><ul><li><p>固定报头：0xB0 02 （剩余长度值）</p></li><li><p>可变报头</p><p><imgsrc="https://s2.loli.net/2022/07/06/yHmSTzX3swG2jUq.png" /></p></li><li><p>有效载荷：没有有效载荷。</p></li></ul><h3 id="publish-发布消息">PUBLISH – 发布消息</h3><ul><li><p>固定报头：0x3? ?? （剩余长度值）</p><p><img src="https://s2.loli.net/2022/07/06/f5MHKziDNUbF3YW.png" /></p><ul><li>重发标志：第1个字节，第3位。为0表示第一次发送，为1表示不是第一次。</li><li>服务质量等级：第1个字节，第2-1位。</li><li>保留标志：第1个字节，第0位。置1则该条报文会发送给后续订阅的设备。</li></ul></li><li><p>可变报头（可变报头按顺序包含主题名和报文标识符）</p><p><img src="https://s2.loli.net/2022/07/11/oNYERg3JCtzD5yW.png" /></p><ul><li>主题名：和主题过滤器一个概念。</li><li>报文标识符：只有当QoS等级是1或2时，报文标识符（PacketIdentifier）字段才能出现在PUBLISH报文中。</li></ul></li><li><p>有效载荷：有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。有效载荷的长度这样计算：用固定报头中的剩余长度字段的值减去可变报头的长度。包含零长度有效载荷的PUBLISH报文是合法的。</p></li></ul><h3 id="puback-发布确认">PUBACK –发布确认</h3><ul><li><p>固定报头：0x40 02 （剩余长度值）</p></li><li><p>可变报头</p><p><imgsrc="https://s2.loli.net/2022/07/07/ZoRkBFUVaeuA6Db.png" /></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32——IIC、SPI通信</title>
    <link href="/2022/07/02/STM32%E2%80%94%E2%80%94IIC%E3%80%81SPI%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/07/02/STM32%E2%80%94%E2%80%94IIC%E3%80%81SPI%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="iic通信">IIC通信</h1><p>I2C(IIC,Inter－IntegratedCircuit),两线式串行总线，它是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据，IIC是半双工通信方式。</p><h2 id="iic协议">IIC协议</h2><ul><li><p>空闲状态</p><p>I2C总线总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。</p></li><li><p>开始信号</p><p>l当SCL为高期间，SDA由高到低的跳变；启动信号是一种电平跳变时序信号，而不是一个电平信号。</p></li><li><p>停止信号</p><p>当SCL为高期间，SDA由低到高的跳变；停止信号也是一种电平跳变时序信号，而不是一个电平信号。</p><p><imgsrc="https://s2.loli.net/2022/07/01/H5vuVkwtqP3W2ab.png" /></p></li><li><p>应答信号ACK</p><p>发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。</p><p><imgsrc="https://s2.loli.net/2022/07/01/z2LpfcTyJiqRKFY.png" /></p></li><li><p>数据的有效性</p><p>I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。</p><p><imgsrc="https://s2.loli.net/2022/07/01/yTSKxDzdNhOmljb.png" /></p></li><li><p>数据传输</p><p>在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。</p></li></ul><h2 id="eeprom24c02">EEPROM（24C02）</h2><p>总容量是256（2K/8)个字节，IIC接口</p><ul><li><p>设备地址</p><p><imgsrc="https://s2.loli.net/2022/07/02/JqUteIgwmVQHzxy.png" /></p></li><li><p>24C02字节写时序</p><p><imgsrc="https://s2.loli.net/2022/07/02/QH8dcXOl3BjpgGu.png" /></p></li><li><p>24C02读时序</p><p><imgsrc="https://s2.loli.net/2022/07/02/QKle2unUTxmvN4p.png" /></p></li></ul><h1 id="spi通信">SPI通信</h1><p>SPI 是英语Serial Peripheralinterface的缩写，顾名思义就是串行外围设备接口。SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线。</p><h2 id="spi接口原理">SPI接口原理</h2><ul><li><p>SPI内部结构简明图</p><p><img src="https://s2.loli.net/2022/07/02/P8FnoSusOWxDqdM.png" /></p><p><strong>SPI接口一般使用4条线通信：</strong></p><p>MISO 主设备数据输入，从设备数据输出。</p><p>MOSI 主设备数据输出，从设备数据输入。</p><p>SCLK时钟信号，由主设备产生。</p><p>CS从设备片选信号，由主设备控制。</p></li><li><p>从选择（NSS）脚管理</p><p>不仅可以使用特定的NSS脚控制片选信号，也可以使用任意的IO口控制片选信号。</p></li><li><p>时钟信号的相位和极性</p><p>SPI_CR寄存器的CPOL和CPHA位，能够组合成四种可能的时序关系。</p><p>CPOL位确定时钟在空闲状态下的电平：CPOL位为0时，时钟信号在空闲时为低电平；CPOL位为1时，时钟信号在空闲时为高电平。</p><p>CPHA位确定数据在时钟的第几个边沿被采集：CPHA位为0时，在第一个边沿被采集；CPHA位为1时，在第二个边沿被采集。</p></li><li><p>数据帧格式</p><p><img src="https://s2.loli.net/2022/07/02/ibJY6WmauqTEOSs.png" /></p><p>LSB：least significant bit 表示二进制数据的最低位</p><p>MSB : most significant bit 表示二进制数据的最高位</p></li><li><p>状态标志</p><p><imgsrc="https://s2.loli.net/2022/07/02/Lg1Ue4Tj2fsCIni.png" /></p></li><li><p>SPI中断</p><p><imgsrc="https://s2.loli.net/2022/07/02/8B7GEpzvOLi9In5.png" /></p></li><li><p>SPI引脚配置</p><p><imgsrc="https://s2.loli.net/2022/07/02/qyh6mjC3AYIcs4n.png" /></p></li><li><p>常用寄存器</p><p><imgsrc="https://s2.loli.net/2022/07/02/azwYEnhDM2OIHyi.jpg" /></p></li><li><p>程序配置过程</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//配置相关引脚的复用功能，使能SPIx时钟</span><span class="token keyword">void</span> <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> GPIO_InitTypeDef<span class="token operator">*</span> GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化SPIx,设置SPIx工作模式</span><span class="token keyword">void</span> <span class="token function">SPI_Init</span><span class="token punctuation">(</span>SPI_TypeDef<span class="token operator">*</span> SPIx<span class="token punctuation">,</span> SPI_InitTypeDef<span class="token operator">*</span> SPI_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能SPIx</span><span class="token keyword">void</span> <span class="token function">SPI_Cmd</span><span class="token punctuation">(</span>SPI_TypeDef<span class="token operator">*</span> SPIx<span class="token punctuation">,</span> FunctionalState NewState<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SPI传输数据</span><span class="token keyword">void</span> <span class="token function">SPI_I2S_SendData</span><span class="token punctuation">(</span>SPI_TypeDef<span class="token operator">*</span> SPIx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> Data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint16_t</span> <span class="token function">SPI_I2S_ReceiveData</span><span class="token punctuation">(</span>SPI_TypeDef<span class="token operator">*</span> SPIx<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">//查看SPI传输状态</span><span class="token function">SPI_I2S_GetFlagStatus</span><span class="token punctuation">(</span>SPI2<span class="token punctuation">,</span> SPI_I2S_FLAG_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul><h2 id="w25qxx芯片">W25QXX芯片</h2><p>W25Q128(W25Q64)将16M(8M)的容量分为256(128)个块（Block），每个块大小为64K字节，每个块又分为16个扇区（Sector），每个扇区4K个字节，一页（Page）是256个字节。W25Qxx的最小擦除单位为一个扇区，也就是每次必须擦除4K个字节。</p><p>W25QXX芯片的操作需要不断查看芯片的数据手册。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32——各类中断</title>
    <link href="/2022/06/21/STM32%E2%80%94%E2%80%94%E5%90%84%E7%B1%BB%E4%B8%AD%E6%96%AD/"/>
    <url>/2022/06/21/STM32%E2%80%94%E2%80%94%E5%90%84%E7%B1%BB%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="各类中断">各类中断</h1><h2 id="外部中断">外部中断</h2><ul><li><p>STM32的每个IO都可以作为外部中断输入。</p></li><li><p>STM32的中断控制器支持19个外部中断/事件请求：线0~15：对应外部IO口的输入中断。</p><p><img src="https://s2.loli.net/2022/06/21/L2tBESiCdhoHV4b.jpg" /></p><p>线16：连接到PVD输出。 线17：连接到RTC闹钟事件。线18：连接到USB唤醒事件。</p></li><li><p>IO口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数</p></li><li><p>中断服务函数列表</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">EXTI0_IRQHandler           EXTI1_IRQHandlerEXTI2_IRQHandler           EXTI3_IRQHandler           EXTI4_IRQHandler           EXTI9_5_IRQHandler         EXTI15_10_IRQHandler       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>外部中断常用库函数</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">GPIO_EXTILineConfig</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> GPIO_PortSource<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> GPIO_PinSource<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//设置IO口与中断线的映射关系</span>   exp<span class="token operator">:</span>  <span class="token function">GPIO_EXTILineConfig</span><span class="token punctuation">(</span>GPIO_PortSourceGPIOE<span class="token punctuation">,</span>GPIO_PinSource2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">EXTI_Init</span><span class="token punctuation">(</span>EXTI_InitTypeDef<span class="token operator">*</span> EXTI_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化中断线：触发方式等</span>ITStatus <span class="token function">EXTI_GetITStatus</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断中断线中断状态，是否发生</span><span class="token keyword">void</span> <span class="token function">EXTI_ClearITPendingBit</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清除中断线上的中断标志位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>EXTI_Init函数</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">EXTI_Init</span><span class="token punctuation">(</span>EXTI_InitTypeDef<span class="token operator">*</span> EXTI_InitStruct<span class="token punctuation">)</span>；<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  <span class="token class-name">uint32_t</span> EXTI_Line<span class="token punctuation">;</span>   <span class="token comment">//指定要配置的中断线           </span>  EXTIMode_TypeDef EXTI_Mode<span class="token punctuation">;</span>   <span class="token comment">//模式：事件 OR中断</span>  EXTITrigger_TypeDef EXTI_Trigger<span class="token punctuation">;</span><span class="token comment">//触发方式：上升沿/下降沿/双沿触发</span>  FunctionalState EXTI_LineCmd<span class="token punctuation">;</span>  <span class="token comment">//使能 OR失能</span><span class="token punctuation">&#125;</span>EXTI_InitTypeDef<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>外部中断的一般配置步骤</p><p><imgsrc="https://s2.loli.net/2022/06/21/y2EqUtG3z4ieCAl.jpg" /></p></li></ul><h2 id="看门狗">看门狗🐕</h2><h3 id="独立看门狗">独立看门狗</h3><ul><li><p>在键值寄存器（<strong>IWDG_KR</strong>）中写入0xCCCC，开始启用独立看门狗。此时计数器开始从其复位值0xFFF递减，当计数器值计数到尾值0x000时会产生一个复位信号（IWDG_RESET）。</p></li><li><p>无论何时，只要在键值寄存器（<strong>IWDG_KR</strong>）中写入0xAAAA（通常说的喂狗）,自动重装载寄存器IWDG_RLR的值就会重新加载到计数器，从而避免看门狗复位。</p></li><li><p>如果程序异常，就无法正常喂狗，从而系统复位。</p></li><li><p>键值寄存器IWDG_KR: 0~15位有效</p><p><imgsrc="https://s2.loli.net/2022/06/22/zsUMBmvEH1RCr8n.png" /></p></li><li><p>预分频寄存器IWDG_PR：0~2位有效。具有写保护功能，要操作先取消写保护</p><p><imgsrc="https://s2.loli.net/2022/06/22/qG8VWswOdaT2leX.png" /></p></li><li><p>重装载寄存器IWDG_RLR：0~11位有效。具有写保护功能，要操作先取消写保护。</p><p><imgsrc="https://s2.loli.net/2022/06/22/5VHZsbEYzdDQL3F.png" /></p></li><li><p>状态寄存器IWDG_SR：0~1位有效</p><p><imgsrc="https://s2.loli.net/2022/06/22/9NXcy6FOptIJ5iV.png" /></p></li><li><p>独立看门狗超时时间</p><p><img src="https://s2.loli.net/2022/06/22/asR8hq2rTjibXPd.png" /></p><p>溢出时间计算：</p><p><em>Tout=((4×2^prer)×rlr)/40</em> (M3)</p><p>其中，Tout为看门狗溢出时间（单位为 ms） prer为看门狗时钟预分频值（IWDG_PR值），范围为 0~7 rlr为看门狗的重装载值（IWDG_RLR的值）；</p></li><li><p>IWDG独立看门狗操作库函数</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">IWDG_WriteAccessCmd</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> IWDG_WriteAccess<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取消写保护：0x5555使能</span><span class="token keyword">void</span> <span class="token function">IWDG_SetPrescaler</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> IWDG_Prescaler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置预分频系数：写PR</span><span class="token keyword">void</span> <span class="token function">IWDG_SetReload</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> Reload<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置重装载值：写RLR</span><span class="token keyword">void</span> <span class="token function">IWDG_ReloadCounter</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//喂狗：写0xAAAA到KR</span><span class="token keyword">void</span> <span class="token function">IWDG_Enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能看门狗：写0xCCCC到KR</span>FlagStatus <span class="token function">IWDG_GetFlagStatus</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> IWDG_FLAG<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//状态：重装载/预分频 更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>独立看门狗操作步骤</p><p><imgsrc="https://s2.loli.net/2022/06/22/ewvgHlyCQROZouD.jpg" /></p></li></ul><h3 id="窗口看门狗">窗口看门狗</h3><p>之所以称为窗口就是因为其喂狗时间是一个有上下限的范围内(窗口），可以通过设定相关寄存器，设定其上限时间（下限固定）。喂狗的时间不能过早也不能过晚。</p><p><img src="https://s2.loli.net/2022/06/22/yI9a1XBegxY8PpQ.png" /></p><ul><li><p>窗口看门狗超时时间</p><p><imgsrc="https://s2.loli.net/2022/06/22/kIKhWvQoDJUlFXL.png" /></p></li><li><p>控制寄存器<strong>WWDG_CR</strong></p><p><img src="https://s2.loli.net/2022/06/22/6ldQkh9fCjZWrw7.png" /></p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">WWDG_Enable</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> Counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启动并设置初始值</span><span class="token keyword">void</span> <span class="token function">WWDG_SetCounter</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> Counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//喂狗</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>配置寄存器WWDG_CFR</p><p><img src="https://s2.loli.net/2022/06/22/FESBmlxQtwpG6aj.png" /></p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">WWDG_EnableIT</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能提前唤醒中断</span><span class="token keyword">void</span> <span class="token function">WWDG_SetPrescaler</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> WWDG_Prescaler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">WWDG_SetWindowValue</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> WindowValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><p>状态寄存器WWDG_SR</p><p><img src="https://s2.loli.net/2022/06/22/Iq5rCw1UnSXcdeO.png" /></p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">FlagStatus <span class="token function">WWDG_GetFlagStatus</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">WWDG_ClearFlag</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>窗口看门狗配置过程</p><p><imgsrc="https://s2.loli.net/2022/06/22/2Z1wRgeSMsp3Nba.jpg" /></p></li></ul><h2 id="通用定时器">通用定时器</h2><h3 id="定时器的功能特点">定时器的功能特点</h3><ul><li>位于低速的APB1总线上(APB1)</li><li>16位向上、向下、向上/向下(中心对齐)计数模式，自动装载计数器（TIMx_CNT）。</li><li>16位可编程(可以实时修改)预分频器(TIMx_PSC)，计数器时钟频率的分频系数 为1～65535 之间的任意数值。</li><li>4 个独立通道（TIMx_CH1~4），这些通道可以用来作为：<ul><li>输入捕获</li><li>输出比较</li><li>PWM 生成(边缘或中间对齐模式)</li><li>单脉冲模式输出</li></ul></li><li>可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用 1个定时器控制另外一个定时器）的同步电路。</li></ul><h3 id="产生中断条件">产生中断条件</h3><ul><li><p>更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)</p></li><li><p>触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)</p></li><li><p>输入捕获</p></li><li><p>输出比较</p></li><li><p>支持针对定位的增量(正交)编码器和霍尔传感器电路</p></li><li><p>触发输入作为外部时钟或者按周期的电流管理</p></li></ul><p>STM32的通用定时器可以被用于：<strong>测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和PWM)等。 </strong></p><h3 id="计数器模式">计数器模式</h3><p>通用定时器可以向上计数、向下计数、向上向下双向计数模式。</p><h3 id="工作流程图">工作流程图</h3><p><img src="https://s2.loli.net/2022/07/04/UlQcE5Xa6WYm8IP.png" /></p><h3 id="内部时钟选择">内部时钟选择</h3><p><img src="https://s2.loli.net/2022/07/04/XVEq68IbgQtJHef.jpg" /></p><h3id="定时器中断实验相关寄存器核心">定时器中断实验相关寄存器（核心）</h3><ul><li><p>计数器当前值寄存器CNT（修改该寄存器，定时器重新计时）</p><p><imgsrc="https://s2.loli.net/2022/07/04/eEyvTiLpUQRPY3G.png" /></p></li><li><p>预分频寄存器TIMx_PSC</p><p><imgsrc="https://s2.loli.net/2022/07/04/ve1wI6GCLR9Mm2Q.png" /></p></li><li><p>自动重装载寄存器（TIMx_ARR)</p><p><imgsrc="https://s2.loli.net/2022/07/04/myzgLZBRoYOTFJG.png" /></p></li><li><p>控制寄存器1（TIMx_CR1）</p><p><imgsrc="https://s2.loli.net/2022/07/04/YOosxQlqHcgvM83.png" /></p></li><li><p>DMA中断使能寄存器（TIMx_DIER）</p><p><imgsrc="https://s2.loli.net/2022/07/04/yeBjxwJYu967Hls.png" /></p></li></ul><h3 id="定时器中断实现步骤">定时器中断实现步骤</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//能定时器时钟。</span><span class="token function">RCC_APB1PeriphClockCmd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化定时器，配置ARR,PSC。</span><span class="token function">TIM_TimeBaseInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启定时器中断，配置NVIC。</span><span class="token keyword">void</span> <span class="token function">TIM_ITConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">NVIC_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能定时器。</span><span class="token function">TIM_Cmd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编写中断服务函数。</span><span class="token function">TIMx_IRQHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32——串口通信</title>
    <link href="/2022/06/06/STM32%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/06/06/STM32%E2%80%94%E2%80%94%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="stm32串口通信">STM32——串口通信</h1><h2 id="端口复用配置过程">端口复用配置过程</h2><ul><li><p>GPIO端口时钟使能</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>复用外设时钟使能</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_USART1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>端口模式配置， GPIO_Init()函数</p><p>查表：《STM32中文参考手册V10》P110的表格“8.1.11外设的GPIO配置”</p><p><imgsrc="https://s2.loli.net/2022/06/06/QkgwiK4VnDqS5rx.png" /></p></li></ul><h3 id="pa9pa10复用为串口1配置过程">PA9,PA10复用为串口1配置过程</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//①IO时钟使能</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_USART1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//②外设时钟使能</span><span class="token comment">//③初始化IO为对应的模式</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_9<span class="token punctuation">;</span> <span class="token comment">//PA.9//复用推挽输出</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span> <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_10<span class="token punctuation">;</span><span class="token comment">//PA10 PA.10 浮空输入</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IN_FLOATING<span class="token punctuation">;</span><span class="token comment">//浮空输入</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2id="端口重映射配置过程串口1为例">端口重映射配置过程（串口1为例）</h2><ul><li><p>使能GPIO时钟（重映射后的IO);</p></li><li><p>使能功能外设时钟（例如串口1);</p></li><li><p>使能AFIO时钟（复用功能时钟），重映射必须使能AFIO时钟</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_AFIO<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><imgsrc="https://s2.loli.net/2022/06/06/WPbwk4N6ZTJrQUE.jpg" /></p></li><li><p>开启重映射</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">GPIO_PinRemapConfig</span><span class="token punctuation">(</span>GPIO_Remap_USART1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>根据第一个参数，来确定是部分重映射还是全部重映射</p></li></ul><h2 id="中断优先级管理nvic">中断优先级管理NVIC</h2><p>首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。</p><ul><li><p>分组配置是在寄存器SCB-&gt;AIRCR中配置：</p><p><imgsrc="https://s2.loli.net/2022/06/06/yUweVIX75obKEOH.jpg" /></p></li><li><p>抢占优先级 &amp; 响应优先级区别：</p><ul><li>高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的</li><li>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断</li><li>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行</li><li>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行</li></ul></li><li><p>中断优先级分组函数：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> NVIC_PriorityGroup<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">assert_param</span><span class="token punctuation">(</span><span class="token function">IS_NVIC_PRIORITY_GROUP</span><span class="token punctuation">(</span>NVIC_PriorityGroup<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  SCB<span class="token operator">-></span>AIRCR <span class="token operator">=</span> AIRCR_VECTKEY_MASK <span class="token operator">|</span> NVIC_PriorityGroup<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>中断参数初始化函数</p><div class="code-wrapper"><pre class="line-numbers language-C" data-language="C"><code class="language-C">void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>中断优先级设置步骤</p><ul><li><p>系统运行后先设置中断优先级分组</p><div class="code-wrapper"><pre class="line-numbers language-C" data-language="C"><code class="language-C">void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);&#x2F;&#x2F;整个系统执行过程中，只设置一次中断分组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>针对每个中断，设置对应的抢占优先级和响应优先级：</p><div class="code-wrapper"><pre class="line-numbers language-C" data-language="C"><code class="language-C">void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数</p></li></ul></li></ul><h2 id="串口通信uart">串口通信UART</h2><h3 id="常见的串行通信接口">常见的串行通信接口：</h3><p><img src="https://s2.loli.net/2022/06/07/GthL4ycmQzYdJeN.jpg" /></p><h3 id="stm32的串口通信接口">STM32的串口通信接口</h3><p>大容量STM32F10x系列芯片，包含3个USART和2个UART</p><ul><li>UART:通用异步收发器</li><li>USART:通用同步异步收发器</li></ul><h3 id="uart异步通信方式引脚">UART异步通信方式引脚</h3><ul><li>-RXD:数据输入引脚，数据接受。</li><li>-TXD:数据发送引脚，数据发送。</li></ul><p><img src="https://s2.loli.net/2022/06/07/d6jFtkirhPKGCle.png" /></p><h3id="stm32串口异步通信需要定义的参数">STM32串口异步通信需要定义的参数</h3><ul><li>起始位</li><li>数据位（8位或者9位）</li><li>奇偶校验位（第9位）</li><li>停止位（1,15,2位）</li><li>波特率设置</li></ul><p><img src="https://s2.loli.net/2022/06/07/XuqSPBKOeo7UxJh.png" /></p><h2 id="串口通信寄存器库函数配置">串口通信寄存器/库函数配置</h2><h3 id="常用的串口相关寄存器">常用的串口相关寄存器</h3><ul><li><p>USART_SR状态寄存器</p></li><li><p>USART_DR数据寄存器</p></li><li><p>USART_BRR波特率寄存器</p><p><strong>波特率计算方法：</strong></p><p><imgsrc="https://s2.loli.net/2022/06/07/m8LPtVbcCihuYHv.png" /></p></li><li><p>USART_CR使能寄存器</p></li></ul><h3 id="串口配置的一般步骤">串口配置的一般步骤</h3><p><img src="https://s2.loli.net/2022/06/07/Uq5ZfjlTMhFSeE6.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32——时钟系统</title>
    <link href="/2022/05/28/STM32%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/05/28/STM32%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="stm32时钟系统">STM32——时钟系统</h1><h2 id="时钟系统框图">时钟系统框图</h2><p><img src="https://s2.loli.net/2022/05/28/Flc5V7svKOeCJMT.png" /></p><ul><li><p>STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL ①HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高 ②HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz③ LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟，WDG ④LSE是低速外部时钟，接频率为32.768kHz的石英晶体，RTC ⑤PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2，倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz</p></li><li><p>系统时钟SYSCLK可来源于三个时钟源： ① HSI振荡器时钟 ②HSE振荡器时钟 ③ PLL时钟</p></li><li><p>STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL输出的2分频、HSI、HSE、或者系统时钟</p></li><li><p>任何一个外设在使用之前，必须首先使能其相应的时钟</p></li></ul><h3 id="蓝色方框时钟源">蓝色方框（时钟源）：</h3><ul><li>HSIRC（内部高速时钟），频率约等于8MHz（由RC振荡器产生的时钟，不十分稳定，可关闭）</li><li>LSI RC（内部低速时钟），频率约等于40KHz，提供给IWDGCLK独立看门狗时钟</li><li>HSE OSC（外部高速时钟），外接晶振产生4-16MHz</li><li>LSEOSC（外部低速时钟），外接晶振32.768KHz，提供给RTC内部实时时钟单元</li><li>PLL（锁相环），可以用于倍频</li></ul><h3 id="灰色梯形选择器">灰色梯形（选择器）</h3><h3 id="黄色方框时钟监视系统">黄色方框（时钟监视系统）</h3><p>一旦HSE失效自动将系统时钟切换至HSI</p><h3 id="mco输出内部时钟">MCO输出内部时钟</h3><h3 id="绿色方框外设">绿色方框（外设）</h3><ul><li>USB时钟，通常48MHz，可预分频 ÷1 or ÷1.5</li><li>AHB预分频器，能产生HCLK时钟</li><li>APB1预分频器，能产生PCLK1时钟，给低频外设提供时钟</li><li>APB2预分频器，能产生PCLK2时钟，给高频外设提供时钟</li></ul><h2 id="rcc相关配置寄存器">RCC相关配置寄存器</h2><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  __IO <span class="token class-name">uint32_t</span> CR<span class="token punctuation">;</span>                <span class="token comment">//HSI,HSE,CSS,PLL等的使能和就绪标志位 </span>  __IO <span class="token class-name">uint32_t</span> CFGR<span class="token punctuation">;</span>           <span class="token comment">//PLL等的时钟源选择，分频系数设定</span>  __IO <span class="token class-name">uint32_t</span> CIR<span class="token punctuation">;</span>               <span class="token comment">// 清除/使能 时钟就绪中断</span>  __IO <span class="token class-name">uint32_t</span> APB2RSTR<span class="token punctuation">;</span>  <span class="token comment">//APB2线上外设复位寄存器</span>  __IO <span class="token class-name">uint32_t</span> APB1RSTR<span class="token punctuation">;</span>   <span class="token comment">//APB1线上外设复位寄存器</span>  __IO <span class="token class-name">uint32_t</span> AHBENR<span class="token punctuation">;</span>    <span class="token comment">//常用使能，DMA，SDIO等时钟使能</span>  __IO <span class="token class-name">uint32_t</span> APB2ENR<span class="token punctuation">;</span>   <span class="token comment">//常用使能，APB2线上外设时钟使能</span>  __IO <span class="token class-name">uint32_t</span> APB1ENR<span class="token punctuation">;</span>   <span class="token comment">//常用使能，APB1线上外设时钟使能</span>  __IO <span class="token class-name">uint32_t</span> BDCR<span class="token punctuation">;</span>        <span class="token comment">//备份域控制寄存器</span>  __IO <span class="token class-name">uint32_t</span> CSR<span class="token punctuation">;</span>           <span class="token comment">//控制状态寄存器</span><span class="token punctuation">&#125;</span> RCC_TypeDef<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="rcc相关头文件和固件库源文件">RCC相关头文件和固件库源文件</h3><p><img src="https://s2.loli.net/2022/05/28/3qkf4WHKbI1ARQX.jpg" /></p><h2 id="systeminit时钟系统初始化函数">SystemInit时钟系统初始化函数</h2><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">SystemInit</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* Reset the RCC clock configuration to the default reset state(for debug purpose) */</span>  <span class="token comment">/* Set HSION bit */</span>  RCC<span class="token operator">-></span>CR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0x00000001</span><span class="token punctuation">;</span>  <span class="token comment">//打开HSI RC（内部高速时钟）</span>  <span class="token comment">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">STM32F10X_CL     </span></span>  RCC<span class="token operator">-></span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xF8FF0000</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>  RCC<span class="token operator">-></span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xF0FF0000</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* STM32F10X_CL */</span>   </span>    <span class="token comment">/* Reset HSEON, CSSON and PLLON bits */</span>  RCC<span class="token operator">-></span>CR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFEF6FFFF</span><span class="token punctuation">;</span>  <span class="token comment">/* Reset HSEBYP bit */</span>  RCC<span class="token operator">-></span>CR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFFFBFFFF</span><span class="token punctuation">;</span>  <span class="token comment">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span>  RCC<span class="token operator">-></span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFF80FFFF</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">STM32F10X_CL</span></span>  <span class="token comment">/* Reset PLL2ON and PLL3ON bits */</span>  RCC<span class="token operator">-></span>CR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xEBFFFFFF</span><span class="token punctuation">;</span>  <span class="token comment">/* Disable all interrupts and clear pending bits  */</span>  RCC<span class="token operator">-></span>CIR <span class="token operator">=</span> <span class="token number">0x00FF0000</span><span class="token punctuation">;</span>  <span class="token comment">/* Reset CFGR2 register */</span>  RCC<span class="token operator">-></span>CFGR2 <span class="token operator">=</span> <span class="token number">0x00000000</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span>STM32F10X_LD_VL<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span> <span class="token punctuation">(</span>STM32F10X_MD_VL<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>defined STM32F10X_HD_VL<span class="token punctuation">)</span></span></span>  <span class="token comment">/* Disable all interrupts and clear pending bits  */</span>  RCC<span class="token operator">-></span>CIR <span class="token operator">=</span> <span class="token number">0x009F0000</span><span class="token punctuation">;</span>  <span class="token comment">/* Reset CFGR2 register */</span>  RCC<span class="token operator">-></span>CFGR2 <span class="token operator">=</span> <span class="token number">0x00000000</span><span class="token punctuation">;</span>      <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>  <span class="token comment">/* Disable all interrupts and clear pending bits  */</span>  RCC<span class="token operator">-></span>CIR <span class="token operator">=</span> <span class="token number">0x009F0000</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* STM32F10X_CL */</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span>STM32F10X_HD<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>defined STM32F10X_XL<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>defined STM32F10X_HD_VL<span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DATA_IN_ExtSRAM</span></span>    <span class="token function">SystemInit_ExtMemCtl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* DATA_IN_ExtSRAM */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>  <span class="token comment">/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */</span>  <span class="token comment">/* Configure the Flash Latency cycles and enable prefetch buffer */</span>  <span class="token function">SetSysClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">VECT_TAB_SRAM</span></span>  SCB<span class="token operator">-></span>VTOR <span class="token operator">=</span> SRAM_BASE <span class="token operator">|</span> VECT_TAB_OFFSET<span class="token punctuation">;</span> <span class="token comment">/* Vector Table Relocation in Internal SRAM. */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>  SCB<span class="token operator">-></span>VTOR <span class="token operator">=</span> FLASH_BASE <span class="token operator">|</span> VECT_TAB_OFFSET<span class="token punctuation">;</span> <span class="token comment">/* Vector Table Relocation in Internal FLASH. */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="systick定时器">SysTick定时器</h2><p>Systick定时器就是系统滴答定时器，一个24 位的倒计数定时器，计到0时，将从RELOAD 寄存器中自动重装载定时初值。</p><h3 id="个寄存器">4个寄存器</h3><ul><li><p>SysTick 控制和状态寄存器（CTRL）</p><p><img src="https://s2.loli.net/2022/05/30/duKBZSHLIqXfCzT.png" /></p><p>对于STM32，外部时钟源是 HCLK(AHB总线时钟)的1/8内核时钟是 HCLK时钟；配置函数：SysTick_CLKSourceConfig()</p></li><li><p>SysTick 重装载数值寄存器（LOAD）</p><p><imgsrc="https://s2.loli.net/2022/05/30/8LFcpaQfeW7dbi9.png" /></p></li><li><p>SysTick 当前值寄存器（VAL）</p><p><imgsrc="https://s2.loli.net/2022/06/01/vaYoqI94LygiJAN.png" /></p></li></ul><h3 id="固件库中的systick相关函数">固件库中的Systick相关函数</h3><ul><li><p>SysTick_CLKSourceConfig() //Systick时钟源选择 misc.c文件中</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">SysTick_CLKSourceConfig</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> SysTick_CLKSource<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* Check the parameters */</span>  <span class="token function">assert_param</span><span class="token punctuation">(</span><span class="token function">IS_SYSTICK_CLK_SOURCE</span><span class="token punctuation">(</span>SysTick_CLKSource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>SysTick_CLKSource <span class="token operator">==</span> SysTick_CLKSource_HCLK<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    SysTick<span class="token operator">-></span>CTRL <span class="token operator">|=</span> SysTick_CLKSource_HCLK<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    SysTick<span class="token operator">-></span>CTRL <span class="token operator">&amp;=</span> SysTick_CLKSource_HCLK_Div8<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>SysTick_Config()//初始化并启动SysTick计数器及其中断，ticks就是LOAD值，即重载值，表示两次中断的计数。</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __INLINE <span class="token class-name">uint32_t</span> <span class="token function">SysTick_Config</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> ticks<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>ticks <span class="token operator">></span> SysTick_LOAD_RELOAD_Msk<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* Reload value impossible */</span>                               SysTick<span class="token operator">-></span>LOAD  <span class="token operator">=</span> <span class="token punctuation">(</span>ticks <span class="token operator">&amp;</span> SysTick_LOAD_RELOAD_Msk<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">/* set reload register */</span>  <span class="token function">NVIC_SetPriority</span> <span class="token punctuation">(</span>SysTick_IRQn<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>__NVIC_PRIO_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* set Priority for Cortex-M0 System Interrupts */</span>  SysTick<span class="token operator">-></span>VAL   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                          <span class="token comment">/* Load the SysTick Counter Value */</span>  SysTick<span class="token operator">-></span>CTRL  <span class="token operator">=</span> SysTick_CTRL_CLKSOURCE_Msk <span class="token operator">|</span>                    SysTick_CTRL_TICKINT_Msk   <span class="token operator">|</span>                    SysTick_CTRL_ENABLE_Msk<span class="token punctuation">;</span>                    <span class="token comment">/* Enable SysTick IRQ and SysTick Timer */</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                  <span class="token comment">/* Function successful */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>Systick中断服务函数，SysTick_Handler(void);</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32——手把手第一段代码编写（IO口的输入、输出）</title>
    <link href="/2022/05/27/STM32%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E7%AC%AC%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%EF%BC%88IO%E5%8F%A3%E7%9A%84%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%EF%BC%89/"/>
    <url>/2022/05/27/STM32%E2%80%94%E2%80%94%E6%89%8B%E6%8A%8A%E6%89%8B%E7%AC%AC%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%EF%BC%88IO%E5%8F%A3%E7%9A%84%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1id="stm32手把手第一段代码编写跑马灯io口输出">STM32——手把手第一段代码编写（跑马灯IO口输出）</h1><h2 id="库函数版本">库函数版本</h2><h3 id="io口操作流程">IO口操作流程</h3><ul><li>使能IO口时钟，调用函数RCC_APB2PeriphColckCmd(),不同的IO组，调用的时钟使能函数不一样</li></ul><p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token operator">|</span>RCC_APB2Periph_GPIOD<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使能PB,PE端口时钟</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></p><ul><li><p>初始化IO口模式，调用函数GPIO_Init()</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_8<span class="token punctuation">;</span> <span class="token comment">//LED0-->PB.5 端口配置</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>  <span class="token comment">//推挽输出</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span> <span class="token comment">//IO口速度为50MHz</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根据设定参数初始化GPIOB.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>操作IO口，输出高低电平</p></li></ul><p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span>GPIO_Pin_8<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//PA.8 输出高</span><span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span>GPIO_Pin_8<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//PA.8 输出低 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></p><h3 id="硬件驱动程序编写">硬件驱动程序编写</h3><p>通常会同时编写一个.c文件和.h文件。</p><ul><li><p>编写.h文件时避免头文件被重复引用</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__XX_H     </span><span class="token comment">//若文件中没有引用xx.h文件，则执行#define __XX_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__XX_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>             <span class="token comment">//若文件中已经引用xx.h文件，则中间内容不被执行</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>编写.c文件时，按照IO口操作流程进行初始化</p></li></ul><h2 id="寄存器版本">寄存器版本</h2><h3 id="io口操作流程-1">IO口操作流程</h3><ul><li><p>使能IO口时钟，配置寄存器RCC_APB2ENR</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span>RCC<span class="token operator">-></span>APB2ENR<span class="token operator">|=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>初始化IO口模式，配置寄存器GPIOx_CRH/CRL</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//GPIOB.5设置成推挽输出</span>GPIOB<span class="token operator">-></span>CRL<span class="token operator">&amp;=</span><span class="token number">0xFF0FFFFF</span><span class="token punctuation">;</span>GPIOB<span class="token operator">-></span>CRL<span class="token operator">|=</span><span class="token number">0x00300000</span><span class="token punctuation">;</span><span class="token comment">//GPIOE.9设置成推挽输出</span>GPIOE<span class="token operator">-></span>CRH<span class="token operator">&amp;=</span><span class="token number">0xFFFFFFF0</span><span class="token punctuation">;</span>GPIOE<span class="token operator">-></span>CRH<span class="token operator">|=</span><span class="token number">0x00000003</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>操作IO口，输出高低电平，配置寄存器GPIOX_ODR或者BSRR/BRR</p></li></ul><p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIOB<span class="token operator">-></span>ODR<span class="token operator">|=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></p><p>## 位操作版本</p><p>IO口操作流程</p><ul><li><p>使能IO口时钟，调用函数RCC_APB2PeriphColckCmd()</p></li><li><p>初始化IO口模式，调用函数GPIO_Init()</p></li><li><p>操作IO口，输出高低电平，使用位带操作</p></li></ul><h1id="stm32手把手第一段代码编写按键io口输入">STM32——手把手第一段代码编写（按键IO口输入）</h1><h3 id="io口操作流程-2">IO口操作流程</h3><ul><li><p>使能按键对应IO口时钟，调用函数：RCC_APB2PeriphClockCmd()</p></li><li><p>初始化IO模式：上拉/下拉输入，调用函数：GPIO_Init()</p></li><li><p>扫描IO口电平（库函数/寄存器/位操作）</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 库函数版本</span><span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span>；GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_5<span class="token punctuation">;</span> <span class="token comment">//按键0-->PA.5 端口配置</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IPU<span class="token punctuation">;</span>      <span class="token comment">//上拉输入</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根据设定参数初始化GPIOA.5</span><span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span>GPIO_Pin_5<span class="token punctuation">)</span><span class="token comment">//读取按键0</span><span class="token comment">// 寄存器版本</span><span class="token keyword">void</span> <span class="token function">KEY_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>RCC<span class="token operator">-></span>APB2ENR<span class="token operator">|=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">//使能PORTA时钟</span>GPIOA<span class="token operator">-></span>CRL<span class="token operator">&amp;=</span><span class="token number">0XFF0FFFFF</span><span class="token punctuation">;</span><span class="token comment">//PC5设置成输入  </span>GPIOA<span class="token operator">-></span>CRL<span class="token operator">|=</span><span class="token number">0X00800000</span><span class="token punctuation">;</span>   GPIOA<span class="token operator">-></span>ODR<span class="token operator">|=</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>   <span class="token comment">//PC5上拉 </span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="按键扫描思路">按键扫描思路</h3><p><img src="https://s2.loli.net/2022/05/28/VtMHro6bONqluZK.png" /></p><p>记录电平跳变并持续一小段时间，则可判断按键按下。</p><h1 id="mdk中寄存器地址名称映射">MDK中寄存器地址名称映射</h1><p><img src="https://s2.loli.net/2022/05/28/kp7mhwo2ldsiKRj.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我和桂电的故事：选择即是热爱</title>
    <link href="/2022/05/26/%E6%88%91%E5%92%8C%E6%A1%82%E7%94%B5%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%9A%E9%80%89%E6%8B%A9%E5%8D%B3%E6%98%AF%E7%83%AD%E7%88%B1/"/>
    <url>/2022/05/26/%E6%88%91%E5%92%8C%E6%A1%82%E7%94%B5%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%9A%E9%80%89%E6%8B%A9%E5%8D%B3%E6%98%AF%E7%83%AD%E7%88%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="我和桂电的故事选择即是热爱">我和桂电的故事：选择即是热爱</h1><p>2016年我和大多数人一样，对于自己未来的职业发展和兴趣爱好不甚了解，经家人推荐，我填报了桂林电子科技大学，并顺利被录取。选择即是热爱，大一我就喜欢上了这所以电子信息见长的大学，这可能是一个男生对技术的尊崇与偏爱。当时校创新实践基地、机器人中心的技术水平和取得的成果让大一的我很是惊讶，很难想象一名本科学生就可以和校外企业合作项目，获得不菲的劳务。而我也在机电工程学院组织的创新文化月中迈出了我技术学习的第一步，那是一台由51单片机控制的计时器，它曾一度让我沉迷其中、废寝忘食。</p><p><img src="https://s2.loli.net/2022/05/26/EMDHvlF7dPcxQzB.gif" alt="STM32跑马灯" style="zoom:200%;" /></p><p>后来由于自己割舍不断的军旅情怀，我选择了参军入伍，待大二复学时转眼已是2019年，经过之前的学习和思考，我对自己有了较为清晰的认识，发现自己对计算机编程和数学有着浓厚的兴趣，所以我选择转入数学与计算科学学院信息与计算科学专业学习。但两年的部队生活，高强度的军事训练，几乎不怎么接触学科知识，这让初返校园连三角函数都已经忘记怎么算的我十分不适，再加上转专业后许多课程需要补，以至于课程冲突最厉害时，同一时间冲突了三门课，所以我只能利用课余时间看书、看慕课进行补课，那段时间自己忙碌而充实。不过在这忙碌学习之余，我还是有幸参加了青春桂电，在这里我认识了很多有趣有义有能力的朋友，我们经常穿着小马甲，拿着手里的相机在校园各处拍摄采访，每当看到自己拍摄的照片和制作的视频在学校新媒体平台上发表时，心里就涌起满满的喜悦和满足，仿佛之前忙碌带来的疲惫一扫而空了。</p><figure><img src="https://s2.loli.net/2022/05/26/vMybTquSwAcJjEt.jpg"alt="校园合唱节拍摄报道" /><figcaption aria-hidden="true">校园合唱节拍摄报道</figcaption></figure><p>到了大三后，自己有了一些沉淀，在学院也慢慢地崭露头角，开始接触一些老师的科研项目，并且带领团队去参加一些比赛。我初次接触导师唐敏副教授是起源于之前参加的学院创新实践基地，在大三时开始实施导师制，我当时就选择了唐敏老师，她是一位很年轻、很负责任的老师，她安排给我们看论文，学习机器学习相关知识，开组会分享本周的学习内容。在她的启发下共同完成了两篇学术论文，并且均投稿在国际知名期刊上，对此我付出了很多努力，也极大开拓了自己的视野。特别是在其中一篇非交互式SVM训练算法的设计上，我创新性地提出了一种通过矩阵分解来分离权重和样本数据的方法，极大改进了隐私保护下SVM模型分布式训练过程，而提出这种创新性的实用方法带来的喜悦无以言表，使我愿意通宵达旦、不眠不休地去实验证明其可靠性。</p><figure><img src="https://s2.loli.net/2022/05/26/Hn4qkhzomwLPgjK.jpg"alt="算法模型图" /><figcaption aria-hidden="true">算法模型图</figcaption></figure><p>此外在校期间，我参加过挑战杯、互联网＋、蓝桥杯、数学建模、数学竞赛等等许多竞赛，也拿了一些奖。曾经我会因为一纸获奖证书而兴奋不已，但其实我回过头看，拥有这些获奖证书好像并没有很大意义，相反能让我津津乐道的还是那些参赛过程。我现在更倾向于去提高自身能力，自身能力提高了，一些奖项自然而然地就来了，而这些竞赛经历也在潜移默化地提升着自身能力。在一个团队中作为负责人往往要承担比其他成员多得多的责任，同样也能收获多得多的成长，我们互联网＋项目团队从组建到进入全国总决赛历时将近一年，团队成员相继加入又相继离场，最后七人的学生团队互相扶持，攻克难关。在这一路上，李冠霖、徐增敏两位老师为我们尽心竭力，帮助我们寻找项目资源、理清项目逻辑，使起先的一个想法最终登上了全国总决赛的舞台。</p><figure><img src="https://s2.loli.net/2022/05/26/cEFQ6k7UpyVDwqX.jpg"alt="第七届“互联网+”大赛" /><figcaption aria-hidden="true">第七届“互联网+”大赛</figcaption></figure><p>长期以来，我始终以“感恩社会，奉献学校，服务师生，锻炼自己”为宗旨，在服务他人的过程中我自己也能得到满足。在抗击新冠肺炎疫情期间，习近平总书记强调，要关心关爱广大医务人员，帮助解决实际困难和问题。江西省团委号召赣籍学子积极响应，开展“为奉献者奉献”志愿关爱行动，对此我凭借自己所学知识，充分发挥数学专业优势，对坚守在防‘疫’一线的医务人员子女的数学和物理学科开展一对一学业辅导，巩固网络教学内容，复习知识点，讲解解题思路，扩展知识面，提升学习兴趣。我辅导的学生有了明显的提升，并在开学后的测试中数学考出了102分的满意成绩。另外，在学习和辅导之余，我还积极投身社区防疫志愿服务，主动担负起晚上通宵执勤监测任务，对外来人员进行严格的体温测量，秉承“无论是谁，没有通行证一律不放行”的原则，坚决阻止病毒携带者进入社区，做到了一切为人民，把人民群众的生命安全和身体健康放在第一位。</p><figure><img src="https://s2.loli.net/2022/05/26/PuE3AIFLS8t52mc.png"alt="医务人员子女线上一对一辅导" /><figcaption aria-hidden="true">医务人员子女线上一对一辅导</figcaption></figure><p>习近平总书记在党的十九大报告中强调：“青年兴则国家兴，青年强则国家强。青年一代有理想、有本领、有担当，国家就有前途，民族就有希望。”作为新时代的中国青年，我将时刻牢记总书记的教诲，努力做到有理想、有本领、有担当，将自己的爱国热情化作行动，将自己的理想和祖国的前途命运结合起来，让青春在党和人民最需要的地方绽放绚丽之花，为社会主义经济建设做出更大贡献，努力在中华民族复兴的伟大实践中书写出一份绚烂无悔的青春篇章。</p><figure><img src="https://s2.loli.net/2022/05/26/zx2KOViYERqPCoM.jpg"alt="小小特种兵夏令营带训" /><figcaption aria-hidden="true">小小特种兵夏令营带训</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32——GPIO工作原理及库函数介绍</title>
    <link href="/2022/05/23/STM32%E2%80%94%E2%80%94GPIO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/05/23/STM32%E2%80%94%E2%80%94GPIO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%93%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="stm32gpio工作原理">STM32——GPIO工作原理</h1><figure><img src="https://s2.loli.net/2022/05/25/lv6ihsOFrq5dKHp.png"alt="GPIO基本结构" /><figcaption aria-hidden="true">GPIO基本结构</figcaption></figure><h2 id="gpio工作模式">GPIO工作模式</h2><ul><li>4种输入模式：输入浮空、 输入上拉、输入下拉、模拟输入</li><li>4种输出模式：开漏输出（当NMOS管导通时，输出低电平；当NMOS管关断时，呈现高阻态）、开漏复用功能、推挽式输出（当PMOS管导通时，输出高电平；当NMOS管导通时，呈现低电平）、推挽式复用功能</li><li>3种最大翻转速度：-2MHZ、-10MHz、-50MHz</li></ul><h2 id="gpio相关配置寄存器">GPIO相关配置寄存器</h2><h3id="两个32位配置寄存器gpiox_crlgpiox_crh">两个32位配置寄存器(GPIOx_CRL,GPIOx_CRH)</h3><p>GPIOx_CRL 端口配置低寄存器 ，GPIOx_CRH 端口配置高寄存器。</p><p><img src="https://s2.loli.net/2022/05/25/7ibaHkBnDUuPRKE.png" /></p><h3id="两个32位数据寄存器gpiox_idrgpiox_odr">两个32位数据寄存器(GPIOx_IDR,GPIOx_ODR)</h3><p>GPIOx_IDR端口输入寄存器，寄存器位上的值为对应IO口的状态：</p><p><img src="https://s2.loli.net/2022/05/25/uC32OFjBmPWpfIM.png" /></p><p>GPIOx_ODR端口输出寄存器，寄存器位上的值为对应IO口的输出电平：</p><p><img src="https://s2.loli.net/2022/05/25/h7XbC31ByLj4OUl.png" /></p><h3 id="一个32位置位-复位寄存器gpiox_bsrr">一个32位置位/复位寄存器(GPIOx_BSRR)</h3><p>可单独修改某一IO口的输出：</p><p><img src="https://s2.loli.net/2022/05/25/s4UEIyTmNcFOhAu.png" /></p><h3 id="一个16位复位寄存器gpiox_brr">一个16位复位寄存器(GPIOx_BRR)</h3><p>该寄存器实际上和GPIOx_BSRR高16位具有同样的功能：</p><p><img src="https://s2.loli.net/2022/05/25/jU6Yr1ukwORmoa7.png" /></p><h3id="一个32位锁定寄存器gpiox_lckr">一个32位锁定寄存器(GPIOx_LCKR)</h3><h1 id="stm32gpio库函数介绍">STM32——GPIO库函数介绍</h1><h2 id="个初始化函数gpio_init">1个初始化函数GPIO_Init：</h2><h3 id="gpio_init函数">GPIO_Init函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> GPIO_InitTypeDef<span class="token operator">*</span> GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>作用：初始化一个或者多个IO口（同一组）的工作方式和速度。</p><p>该函数主要是操作GPIO_CRL(CRH)寄存器，在上拉或者下拉的时候有设置BSRR或者BRR寄存器。</p><p>GPIOx: GPIOA~GPIOG</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>     <span class="token comment">//GPIO的七个寄存器</span>  __IO <span class="token class-name">uint32_t</span> CRL<span class="token punctuation">;</span>  __IO <span class="token class-name">uint32_t</span> CRH<span class="token punctuation">;</span>  __IO <span class="token class-name">uint32_t</span> IDR<span class="token punctuation">;</span>  __IO <span class="token class-name">uint32_t</span> ODR<span class="token punctuation">;</span>  __IO <span class="token class-name">uint32_t</span> BSRR<span class="token punctuation">;</span>  __IO <span class="token class-name">uint32_t</span> BRR<span class="token punctuation">;</span>  __IO <span class="token class-name">uint32_t</span> LCKR<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> GPIO_TypeDef<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">;</span>            <span class="token comment">//指定要初始化的IO口         </span>    GPIOSpeed_TypeDef GPIO_Speed<span class="token punctuation">;</span> <span class="token comment">//设置IO口输出速度</span>    GPIOMode_TypeDef GPIO_Mode<span class="token punctuation">;</span>    <span class="token comment">//设置工作模式：8种中的一个</span><span class="token punctuation">&#125;</span>GPIO_InitTypeDef<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="gpio_init函数初始化样例">GPIO_Init函数初始化样例</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_5<span class="token punctuation">;</span> <span class="token comment">//LED0-->PB.5 端口配置</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>  <span class="token comment">//推挽输出</span>GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span> <span class="token comment">//IO口速度为50MHz</span><span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根据设定参数初始化GPIOB.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="个读取输入电平函数">2个读取输入电平函数</h2><h3 id="gpio_readinputdatabit函数">GPIO_ReadInputDataBit函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> <span class="token function">GPIO_ReadInputDataBit</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span><span class="token operator">*</span> GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>作用：读取某个GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。</p><p>例如：GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_5);//读取GPIOA.5的输入电平。</p><h3 id="gpio_readinputdata函数">GPIO_ReadInputData函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint16_t</span> <span class="token function">GPIO_ReadInputData</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>作用：读取某组GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。</p><p>例如：GPIO_ReadInputData(GPIOA);//读取GPIOA组中所有io口输入电平。</p><h2 id="个读取输出电平函数">2个读取输出电平函数</h2><h3 id="gpio_readoutputdatabit函数">GPIO_ReadOutputDataBit函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> <span class="token function">GPIO_ReadOutputDataBit</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>作用：读取某个GPIO的输出电平。实际操作的是GPIO_ODR寄存器。</p><p>例如：GPIO_ReadOutputDataBit(GPIOA,GPIO_Pin_5);//读取GPIOA.5的输出电平。</p><h3 id="gpio_readoutputdata函数">GPIO_ReadOutputData函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint16_t</span> <span class="token function">GPIO_ReadOutputData</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>作用：读取某组GPIO的输出电平。实际操作的是GPIO_ODR寄存器。</p><p>例如：GPIO_ReadOutputData(GPIOA);//读取GPIOA组中所有io口输出电平。</p><h2 id="个设置输出电平函数">4个设置输出电平函数</h2><h3 id="gpio_setbits函数">GPIO_SetBits函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>作用：设置某个IO口输出为高电平（1），实际操作BSRR寄存器。</p><h3 id="gpio_resetbits函数">GPIO_ResetBits函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>作用：设置某个IO口输出为低电平（0），实际操作的BRR寄存器。</p><h3 id="gpio_writebitgpio_write函数">GPIO_WriteBit，GPIO_Write函数</h3><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">GPIO_WriteBit</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">,</span> BitAction BitVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">GPIO_Write</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> PortVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>这两个函数不常用，也是用来设置IO口输出电平。</p><h1 id="stm32-命名规则">STM32 命名规则</h1><figure><img src="https://s2.loli.net/2022/05/24/6FjI35sY8vGnfOy.png"alt="STM32 命名规则" /><figcaption aria-hidden="true">STM32 命名规则</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理——第三章（模拟调制）</title>
    <link href="/2022/03/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6%EF%BC%89/"/>
    <url>/2022/03/20/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="通信原理第三章模拟调制">通信原理——第三章（模拟调制）</h1><h2 id="模拟调制">3.1模拟调制</h2><p>1）模拟信号m(t)</p><p>𝑚(𝑡)通常是𝑡的连续函数，其特征可以表述为：时间连续、取值连续。<strong>m(t)无直流分量</strong>，时域上均值为0，频域上在原点处没有冲激。</p><p>模拟基带信号𝑚(𝑡)的传输可以有以下几种情形：</p><p><img src="https://s2.loli.net/2022/03/20/wgflxOCnBFGK4pE.png" /></p><ul><li>无失真信道</li></ul><p>无失真：波形的形状不变，可以有延迟，可以幅度不同</p><p>2）系统模型</p><p><img src="https://s2.loli.net/2022/03/20/mXf9bod3hBW1Fen.png" /></p><p>m(t)调制信号，s(t)已调信号。</p><p>3）模拟调制的典型方法</p><ul><li>幅度类调制： s(t)的复包络就是m(t)——DSB-SC 包络就是m(t)——AM复包络的实部就是m(t)——SSB</li><li>角度类调制 复包络的相位与m(t)成正比——PM相位的斜率与m(t)成正比——FM</li></ul><p>4）关键性能指标</p><ul><li>发送端：已调信号的带宽及频谱特征 涉及频谱资源的消耗</li><li>接收端：输出信噪比 涉及对功率资源的消耗</li></ul><h2 id="双边带抑制载波调制dsb-sc">3.2双边带抑制载波调制（DSB-SC）</h2><p><img src="https://s2.loli.net/2022/03/20/LzSGT9FW5iQAlME.png" /></p><p>在载频𝑓c两旁有两个对称的边带（sideband），所以叫双边带；由于默认𝑚(𝑡)是零均值，不包含直流分量（𝑓=0处无冲激），所以叫抑制载波。</p><p>理解：因为需要把频谱分别往左右搬移，时域的相乘等于频域的卷积，正弦信号的频谱是-fc,+fc处的两个冲激，所以原信号频谱与正弦信号的频谱进行卷积就是把频谱分别往左右搬移。</p><h2 id="dsb-sc的相干解调">3.3DSB-SC的相干解调</h2><p><img src="https://s2.loli.net/2022/03/20/gifDBQdZPbMrvzX.png" /></p><p><img src="https://s2.loli.net/2022/03/20/qr9wNjnIXcQg7mL.png" /></p><p>调制信号通过解调器后，可以分解成原信号与一个高频部分的叠加。经过低通滤波器后，高频部分被滤除。</p><ul><li>载波不同步：这个问题在卓晴老师的信号与系统课程中的第四章有详细描述。<ahref="https://2022xi.cn/2022/03/10/信号与系统——第四章（频谱分析技术应用）/#信号的解调">信号与系统——第四章（频谱分析技术应用）- 舍功利之心，注一腔热情。 (2022xi.cn)</a></li><li>相干解调：如果解调器必须要有和发送信号同步的的载波，称此解调为相干解调，否则就是非相干解调。</li><li><strong>DSB-SC只能相干解调。</strong></li><li>导频辅助的载波同步</li></ul><p><img src="https://s2.loli.net/2022/03/22/a3yXFzqUvPIHifw.png" /></p><p>所增加的𝑎⋅𝑐(𝑡)叫导频</p><h2 id="包络调制am">3.4包络调制（AM）</h2><p><img src="https://s2.loli.net/2022/03/20/NCxVPZ3hInuTqKW.png" /><span class="math display">\[s(t) = {A_c}\cos (2\pi {f_c}t) + A&#39;m(t)\cos (2\pi {f_c}t)\]</span></p><p>AM信号其实是DSB-SC信号𝐴′𝑚 (𝑡) cos(2𝜋𝑓c 𝑡)叠加了导频𝐴c ·cos(2𝜋𝑓c 𝑡)，但导频的大小需要足够大，以保证载波振幅（即包络）𝑉(𝑡) = 𝐴(𝑐) + 𝐴′𝑚(𝑡) ≥0. （相当与卓晴老师讲的普通调制）</p><ul><li>包络检波器是非相干解调，不需要载波同步。</li></ul><h2 id="am的调幅系数及调制效率">3.5AM的调幅系数及调制效率</h2><p>1）调幅系数</p><p>AM是DSB-SC插入了一个载波，其信号表达式为：<imgsrc="https://s2.loli.net/2022/03/21/185iZ2ymzvIKMYr.png" /></p><p>称a为AM的调制指数或调幅系数。<imgsrc="https://s2.loli.net/2022/03/21/N4FdjfRQcDWV93K.png" /></p><p>2）调制效率</p><p>AM是DSB-SC插入导频，信息携带在DSB-SC中，DSB-SC部分的功率在总功率中的占比叫调制效率。</p><p><strong>调制效率：</strong></p><p><img src="https://s2.loli.net/2022/03/21/FtVhokCx6X3BcZO.png" /></p><p><img src="https://s2.loli.net/2022/03/21/hrkdKGpeo7WujzN.png" /></p><h2 id="单边带信号ssb">3.6单边带信号（SSB）</h2><p><img src="https://s2.loli.net/2022/03/21/YJ48kcfe7aEbNiQ.png" /></p><p>实现SSB的方法例如可以用滤波器：将DSB信号通过一个适当的滤波器去除两个边带中的一个。</p><ul><li><p>上单边带调制（USB）</p><p>单边带信号的复包络是一个解析信号</p></li></ul><p><span class="math display">\[\begin{array}{l}{s_{L,USB} }(t) = \frac{ { {A_c} } }{2} \cdot [m(t) + j \cdot \hatm(t)]\\{s_{USB} }(t) = \frac{ { {A_c} } }{2} \cdot [m(t)\cos 2\pi {f_c}t - \hatm(t)\sin 2\pi {f_c}t]\end{array}\]</span></p><ul><li>下单边带调制（LSB） 单边带信号的复包络是一个解析信号的共轭</li></ul><p><span class="math display">\[\begin{array}{l}{s_{L,LSB} }(t) = \frac{ { {A_c} } }{2} \cdot [m(t) - j \cdot \hatm(t)]\\{s_{LSB} }(t) = \frac{ { {A_c} } }{2} \cdot [m(t)\cos 2\pi {f_c}t + \hatm(t)\sin 2\pi {f_c}t]\end{array}\]</span></p><p><img src="https://s2.loli.net/2022/03/22/xlJF5jrK8ovNVqg.png" /><strong>SSB解调：</strong>相干解调，得到带通信号的复包络的实部。</p><h2 id="抗噪声性能">3.7抗噪声性能</h2><p>解调输出端的信噪比：平均信号功率/平均噪声功率</p><p>1）DSB-SC相干解调</p><p><img src="https://s2.loli.net/2022/03/22/TapwJX3B2sicFxv.png" /></p><p>𝑟(𝑡)的同相分量是𝑠(𝑡)的同相分量加上𝑛(𝑡)的同相分量。窄带噪声𝑛(𝑡)可以表示为:<span class="math display">\[n(t) = {n_c}(t)\cos 2\pi {f_c}t - {n_s}(t)\sin 2\pi {f_c}t\]</span> <imgsrc="https://s2.loli.net/2022/03/22/6g5VxGY3zWnl7TF.png" /></p><p><img src="https://s2.loli.net/2022/03/22/a7slq3OwyWY1vUH.png" /></p><p>解调输出信噪比是： <span class="math display">\[{(\frac{S}{N})_o} = \frac{ {\overline { { {[{A_c}m(t)]}^2} } } }{{E[n_c^2(t)]} } = \frac{ {2{P_R} } }{ { {N_0}B} } = \frac{ { {P_R} } }{{ {N_0}W} }\]</span> 2）AM相干解调</p><p><img src="https://s2.loli.net/2022/03/22/Bqu4PtCGiaScHo7.png" /></p><p>由于隔直流的原因，最后的输出𝑦(𝑡)仍然保持不变，输出信噪比也不变。</p><p>AM的调制效率𝜂是其DSB-SC部分的功率𝑃R′在𝑠(𝑡)总功率𝑃R中的占比： <spanclass="math display">\[\eta  = \frac{ { { {P&#39;_R} } } }{ { {P_R} } }\quad \quad {P&#39;_R} =\eta {P_R}\]</span> 将这个关系代入便得到AM相干解调的输出信噪比为： <spanclass="math display">\[{(\frac{S}{N})_o} = \frac{ {2{ {P&#39;_R} } } }{ { {N_0}B} } = \eta\frac{ { {P_R} } }{ { {N_0}W} }\]</span> 3）SSB相干解调</p><p><img src="https://s2.loli.net/2022/03/22/ZT5cnafSRdyur8m.png" /></p><p>s(t)的功率是𝑃R，则𝑃R′=𝑃R/2</p><p>解调输出信噪比是： <span class="math display">\[{(\frac{S}{N})_o} = \frac{ {2{ {P&#39;_R} } } }{ { {N_0}B} } = \frac{ {{P_R} } }{ { {N_0}W} }\]</span></p><p>4）AM包络检波</p><p>系统模型：</p><p><img src="https://s2.loli.net/2022/03/23/5PziYjTIUpKwSoG.png" /></p><p>包络检波器的功能：输出是输入带通信号的包络</p><p>输入信号r(t)=s(t)+n(t)</p><p><img src="https://s2.loli.net/2022/03/23/83QBciSHgXuovsL.png" /></p><p>包络是：<imgsrc="https://s2.loli.net/2022/03/23/gjZkzRtLlJpVI1q.png" /></p><p>期望信号𝑠(𝑡)的功率远大于噪声𝑛(𝑡)的功率时的高信噪比条件下，包络可近似为：<imgsrc="https://s2.loli.net/2022/03/23/jDfaPcztJFOKw9L.png" /></p><p>输出结果与AM相干解调相同，所以信噪比也和AM相干解调相同。</p><h2 id="角度调制">3.8角度调制</h2><p>角度类调制：包络是常数，信息m(t)携带在复包络的相位中</p><p>FM/PM： <span class="math display">\[A(t) = {A_c},\varphi (t) \sim m(t)\]</span> <imgsrc="https://s2.loli.net/2022/03/23/WlzeOBU7cdghR9x.png" /></p><p>角度调制：借助有意为之的位置或速度晃动携带信息。</p><p>线性调相（PM）：瞬时相位偏移与𝑚(𝑡)成正比</p><p><img src="https://s2.loli.net/2022/03/23/iWzDrZRcL1kNKG2.png" /></p><p>线性调频（FM）：瞬时频率偏移与𝑚(𝑡)成正比</p><p><img src="https://s2.loli.net/2022/03/23/oUDxZLkuvir5b2q.png" /></p><p>FM与PM之间的关系：</p><ul><li>微分之后再调频（FM），结果是调相（PM）;</li><li>积分之后再调相（PM），结果是调相（FM）。</li></ul><p>最大频偏：<imgsrc="https://s2.loli.net/2022/03/23/lNVCc73RD6E8MBZ.png" /></p><p>调频指数：定义为最大频偏按基带信号的最高频率归一化 <spanclass="math display">\[{\beta _f} \buildrel \Delta \over = \frac{ {\Delta {f_{\max } } } }{W}\]</span></p><h2 id="角度调制信号的频谱特性">3.9角度调制信号的频谱特性</h2><p>1）单音调频（初相位为0的余弦信号）<imgsrc="https://s2.loli.net/2022/03/23/PK6jiz4pOrHck2B.png" /></p><p><img src="https://s2.loli.net/2022/03/23/JGWb9x32YfR1uni.png" /></p><p>其中，调制指数： <span class="math display">\[\beta  = \frac{ {\Delta {f_{\max } } } }{ { {f_m} } } = \frac{ {{A_m}{K_f} } }{ { {f_m} } }\]</span></p><p><img src="https://s2.loli.net/2022/03/23/TeKPnwmDXoUx6Wy.png" /></p><p>对这个复包络傅里叶变换不容易求，需要对其进行傅里叶级数分解：</p><p><img src="https://s2.loli.net/2022/03/23/SqGXT5WE2UAxukO.png" /></p><p>根据傅里叶级数展开式可以写出复包络的频谱为：</p><p><img src="https://s2.loli.net/2022/03/23/BcLb4fgWmGXUKTs.png" /></p><p>J𝑛(𝛽)是第一类𝑛阶贝塞尔函数，函数值从趋势上来说是随|𝑛|的增加而减小，所以大部分能量集中在|𝑛|比较小的范围内。</p><p><strong>2）卡松公式</strong></p><ul><li><p>单音调频的结果表明FM信号的有效带宽集中在载频附近的一个范围内。</p></li><li><p>一般情况下，角度调制信号的带宽的近似计算公式为：</p></li></ul><p><span class="math display">\[\begin{array}{l}B \approx 2(\Delta {f_{\max } } + {f_m})\\B \approx 2{f_m}({\beta _f} + 1)\end{array}\]</span></p><h2 id="fm的抗噪声性能">3.10FM的抗噪声性能</h2><p>1）系统模型</p><p><img src="https://s2.loli.net/2022/03/23/B8Qy4GtgAaW5skf.png" /></p><p>带通滤波器的带宽： <span class="math display">\[B = 2({\beta _f} + 1)W\]</span> 到达解调器的信号为：</p><p><img src="https://s2.loli.net/2022/03/23/JZAKycR8NDHmXqv.png" /></p><p>其中期望信号𝑠(𝑡)的功率为： <span class="math display">\[{P_R} = \overline { {s^2}(t)}  = \frac{ {A_c^2} }{2}\]</span> <imgsrc="https://s2.loli.net/2022/03/23/VjSoBLGX9parn18.png" /></p><p>𝑛c(𝑡)、𝑛s(𝑡𝑡)的功率谱密度是𝑛(𝑡)功率谱密度左移、右移后叠加：</p><p><img src="https://s2.loli.net/2022/03/23/3vTyLawB8HDs6xG.png" /></p><p>可以理解为功率谱密度左移、右移叠加后，功率谱密度的面积不变，所以𝑛(𝑡)及其同相、正交分量有相同的功率。</p><ul><li>鉴频器的功能：输出带通信号的瞬时频偏</li></ul><p>2）噪声为零时的输出信号功率</p><p>关掉噪声时，鉴频器输入为r(t)=s(t)</p><p><img src="https://s2.loli.net/2022/03/23/guGhnjacts7MPYE.png" /></p><p>输出端期望信号功率为：<imgsrc="https://s2.loli.net/2022/03/23/rmLIckQvUzbRs1S.png" /></p><p>3）𝒎(𝒕)=𝟎时的输出噪声功率</p><p>𝑚(𝑡)=0时，鉴频器输入成为：<imgsrc="https://s2.loli.net/2022/03/24/5LHjBf3kzJ2N4I9.png" /></p><p>𝑟(𝑡)的复包络是：</p><p><img src="https://s2.loli.net/2022/03/24/IGeNOdn2WKkcbz7.png" /></p><p>鉴频器输出是：<imgsrc="https://s2.loli.net/2022/03/24/aoKfWxe7b8RtXzh.png" /></p><p>参考下面的图，𝐴c充分大时</p><p><img src="https://s2.loli.net/2022/03/24/aWM738EpjheBJq6.png" /></p><p>于是，鉴频器输出近似为：<imgsrc="https://s2.loli.net/2022/03/24/OAIMqDVuzN4b8wg.png" /></p><p>此信号通过截止频率为𝑊的LPF，输出噪声功率是：<imgsrc="https://s2.loli.net/2022/03/24/CIWz6rjcPUBJ7me.png" /></p><p>微分是传递函数为 <em>j2𝜋f</em> 的线性系统，所以有：</p><p><img src="https://s2.loli.net/2022/03/24/GeuOi8Kv72FVUdS.png" /></p><p>所以，输出噪声功率为：</p><p><img src="https://s2.loli.net/2022/03/24/qmDLVer7ZSOvN4c.png" /></p><p><strong>噪声为0与输入为0的两个结果相除便得到输出信噪比：</strong></p><p><img src="https://s2.loli.net/2022/03/24/M6jLZvtlnmSpBsK.png" /></p><h2 id="频分复用">3.11频分复用</h2><p>复用（multiplexing）的意思是将多个信息信号合在一起，变成一个信号后传输。</p><ul><li>频分复用（FDM）、时分复用（TDM）、码分复用（CDM）</li></ul><p>复合调制：FDM形成的合成信号一般是一个带宽更宽的模拟基带信号，为了通过带通信道传输，还需要再进行一次调制。</p><p><img src="https://s2.loli.net/2022/03/24/CRXsULpJ6PjBzZo.png" /></p><h2 id="载波同步问题">3.12载波同步问题</h2><p>正弦调制所用的载波是正弦波，也叫单频载波、连续波。</p><p>1）发送信号中直接包含发送载波，收端可以从接收信号中直接提取出相干解调所需的载波。</p><ul><li>DSB-SC插入导频 <imgsrc="https://s2.loli.net/2022/03/24/5ydRoiXV7m8OWhY.png" /></li><li>AM</li></ul><p>2）发送信号中不包含发送载波</p><ul><li><p>平方环法 <imgsrc="https://s2.loli.net/2022/03/24/8vLpMdCz6sNhZGc.png" />y(t)中包含一个基带信号和带通信号，带通信号均值不为零，则可通过滤波提出这个分量，然后二分频便得到所需的载波。</p><p><imgsrc="https://s2.loli.net/2022/03/24/ymkWhLGZwS6Hogb.png" /></p></li><li><p>科斯塔斯环法 <imgsrc="https://s2.loli.net/2022/03/24/zhZB9HotkWjf2pa.png" />信号分别通过两个滤波器输出信号的同相分量 I(t) 和正交分量 Q(t)，二者相乘后可得： <imgsrc="https://s2.loli.net/2022/03/24/6BAl8ivbrDZu4kW.png" />即若0&lt;𝜃−𝜑&lt;𝜋/2，那么𝐼(𝑡)×𝑄(𝑡)为正，VCO的频率增高，𝜑增加，𝜃−𝜑减小，𝜑滞后的情况改善。</p></li><li><p>0,𝜋相位模糊获得的载波信号可能与原信号相同，也可能与原信号相差一个𝜋。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理——第二章（随机信号分析）</title>
    <link href="/2022/03/16/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2022/03/16/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1id="通信原理第二章随机信号分析">通信原理——第二章（随机信号分析）</h1><h2 id="随机过程">2.1随机过程</h2><p>随机变量：随机实验的样本空间是实数集合，随机变量𝑋𝑋表示从许多实数{𝑥1,𝑥2,⋯}中随机抽一个。</p><p>随机过程：随机过程也叫随机信号，其随机实验的样本空间是函数的集合。</p><p>随机过程𝑋(𝑡)表示从许多实函数{𝑥1(𝑡),𝑥2(𝑡),⋯}中随机抽一个。</p><ul><li>随机过程的数学期望是一个关于时间t的函数，是某时刻t所有取值的均值。</li><li>任意随机过程可以看成是零均值过程与确定函数的和。</li><li>X(t),Y(t)的互相关函数</li></ul><p><span class="math display">\[{R_{XY} }({t_1},{t_2}) = E[X({t_1})Y({t_2})]\]</span></p><p>概率论中有： <span class="math display">\[{\mathop{\rm cov} } (X,Y) = E(X)E(Y) - E(XY)\]</span></p><ul><li>自相关函数：</li></ul><p><span class="math display">\[{R_X}(t + \tau ,t) = E[X(t + \tau )X(t)]\]</span></p><ul><li><strong>平均自相关函数：</strong>对t做时间平均</li></ul><p><span class="math display">\[{\bar R_X}(\tau ) = \overline {E[X(t + \tau )X(t)]}  = E[\overline {X(t+ \tau )X(t)} ]\]</span></p><h2 id="功率谱密度">2.2功率谱密度</h2><ul><li>对单个样本函数的功率谱密度做统计平均的结果就是随机过程的功率谱密度：</li></ul><p><img src="https://s2.loli.net/2022/03/17/XoE9f2FxPYOgse8.png" /></p><ul><li>随机过程的平均功率谱密度是平均自相关函数的傅里叶变换（维纳-辛钦定理）。</li><li>随机过程X(t)的平均功率为：<imgsrc="https://s2.loli.net/2022/03/17/nTjS1vQJz3k6pad.png" /></li><li>两个零均值不相关的随机过程和的功率谱密度是两个功率谱密度之和。</li><li>若𝑋(𝑡)是零均值随机过程、𝑚(𝑡)是确定的实功率信号，则𝑋(𝑡)+𝑚(𝑡)的功率谱密度是𝑃𝑋(𝑓)+𝑃𝑚(𝑓)。</li></ul><h2 id="广义平稳过程">2.3广义平稳过程</h2><p>如果𝑋(𝑡)的均值、自相关函数都与绝对时间𝑡无关，就叫广义平稳过程： <spanclass="math display">\[\begin{array}{l}E[X(t)] = {m_X}\\E[X(t + \tau )X(t)] = {R_X}(\tau )\end{array}\]</span></p><ul><li>遍历性：所有的样本函数都有相同的均值和自相关函数</li></ul><p><span class="math display">\[\begin{array}{l}P\{ \overline {x(t)}  = {m_x}\}  = 1\\P\{ \overline {x(t + \tau )x(t)}  = R(\tau )\}  = 1\end{array}\]</span></p><p>均值和自相关满足遍历性的平稳过程叫做广义遍历过程。</p><ul><li>平稳过程自相关函数的傅里叶变换就是功率谱密度，因为平稳过程自相关函数本身就与自变量t无关。</li></ul><h2 id="联合平稳">2.4联合平稳</h2><ul><li>两个平稳过程X(t)、Y(t)的互相关函数也与变量t无关：</li></ul><p><span class="math display">\[E[X(t + \tau )Y(t)] = {R_{XY} }(\tau )\]</span></p><ul><li>两个随机过程不相关：</li></ul><p><span class="math display">\[\begin{array}{l}\forall {t_1},{t_2}\quad E[X({t_1})Y({t_2})] = E[X({t_1})]E[Y({t_2})]\\\quad \quad \quad {R_{XY} }({t_1},{t_2}) = {m_X}({t_1}){m_Y}({t_2})\end{array}\]</span></p><ul><li>两个随机过程同一时刻不相关</li><li>零均值随机变量的相关系数（与概率论中类似）：</li></ul><p><span class="math display">\[{\rho _{XY} } = E[\frac{X}{ {\sqrt {E[{X^2}]} } } \cdot \frac{Y}{ {\sqrt{E[{Y^2}]} } }] = \frac{ {E[XY]} }{ {\sqrt {E[{X^2}]E[{Y^2}]} } }\]</span></p><ul><li>零均值联合平稳过程的相关系数</li></ul><p><span class="math display">\[{\rho _{XY} }(\tau ) = E[\frac{ {X(t + \tau )} }{ {\sqrt {E[{X^2}]} } }\cdot \frac{ {Y(t)} }{ {\sqrt {E[{Y^2}]} } }] = \frac{ { {R_{XY} }(\tau)} }{ {\sqrt {E[{X^2}]E[{Y^2}]} } }\]</span></p><p>1）对所有时间间隔相关系数都等于0，则两个平稳过程不相关</p><p>2）对时间间隔为0时，相关系数都等于0，则同一时刻不相关</p><h2 id="平稳过程通过线性系统">2.5平稳过程通过线性系统</h2><ul><li>平稳过程通过线性系统后的均值：</li></ul><p><img src="https://s2.loli.net/2022/03/20/PktNaD25KgCSh81.png" /></p><ul><li>平稳过程通过线性系统后的自相关函数：</li></ul><p><img src="https://s2.loli.net/2022/03/20/VMsPEaByIDlCkwK.png" /></p><p><strong>Y(t)也是平稳过程</strong>，并且X(t)与Y(t)是联合平稳的。</p><ul><li>输出的功率谱密度：</li></ul><p><span class="math display">\[{P_Y}(f) = {\left| {H(f)} \right|^2}{P_X}(f)\]</span></p><p>零均值平稳过程希尔伯特变换后的均值为0，不改变自相关函数及功率谱密度；希尔伯特变换与原函数的互相关函数是原函数的自相关函数的希尔伯特变换；输入与输出在同一时刻不相关。</p><h2 id="复平稳过程">2.6复平稳过程</h2><p><strong>复随机过程是一对实随机过程</strong></p><ul><li>复随机过程的相关函数：</li></ul><p><span class="math display">\[{ {R_{ {Z_1}{Z_2} } } }({t_1},{t_2}) = E[Z_1({t_1}){Z_2^*}({t_2})]\]</span></p><ul><li>共轭相关函数：</li></ul><p><span class="math display">\[{R_{Z{Z^*} } }({t_1},{t_2}) = E[Z({t_1})Z({t_2})]\]</span></p><p>复随机过程Z(t)与Z(t)共轭的相关函数。</p><ul><li>复平稳：若复随机过程𝑍(𝑡)的实部𝑋(𝑡)与虚部𝑌(𝑡)都是平稳过程，并且二者联合平稳。</li></ul><p><img src="https://s2.loli.net/2022/03/17/dSKs92aB76kIhoz.png" /></p><h2id="平稳带通过程的解析信号及复包络">2.7平稳带通过程的解析信号及复包络</h2><p>1）解析信号</p><p>平稳带通过程的解析信号是复平稳过程。</p><ul><li>解析信号Z(t)的自相关函数：</li></ul><p><span class="math display">\[{R_Z}(\tau ) = 2[{R_X}(\tau ) + j \cdot {\hat R_X}(\tau )\]</span></p><p>解析信号的自相关函数是原自相关函数的解析信号的2倍。</p><ul><li>解析信号的功率谱密度，解析信号𝑍(𝑡)是𝑋(𝑡)通过传递函数为1+sgn(𝑓)的滤波器的输出，𝑍(𝑡)的功率谱密度为：</li></ul><p><img src="https://s2.loli.net/2022/03/18/NRwohU6b9XJenOQ.png" /></p><ul><li>解析信号Z(t)的共轭相关函数等于0，零均值平稳过程的解析信号共轭不相关。</li></ul><p>2）X(t)的复包络</p><ul><li><p><span class="math display">\[{X_L}(t) = Z(t){e^{ - j2\pi {f_c}t} }\]</span></p></li><li><p>复包络的均值是0</p></li><li><p>复包络的自相关函数</p></li></ul><p><span class="math display">\[E[{X_L}(t + \tau )X_L^*(t)] = {R_Z}(\tau ){e^{ - j2\pi {f_c}\tau } }\]</span></p><ul><li>复包络的共轭相关函数等于0</li><li>零均值平稳带通过程的复包络是零均值复平稳过程。</li><li>复包络的功率谱密度：</li></ul><p><span class="math display">\[{P_L}(f) = 4{P_X}(f + {f_c}),\quad \left| f \right| \le {f_c}\]</span></p><ul><li>复包络的同相分量及正交分量有相同的自相关函数、功率谱密度：</li></ul><p><span class="math display">\[{R_c}(\tau ) = {R_s}(\tau ) = \frac{1}{2}{\mathop{\rm Re}\nolimits} \{{R_L}(\tau )\}\]</span></p><ul><li>同相分量和正交分量的互相关函数：</li></ul><p><span class="math display">\[{R_{cs} }(\tau ) =  - \frac{1}{ {4j} }{R_L}(\tau ) + \frac{1}{ {4j}}R_L^*(\tau ) =  - \frac{1}{2}{\mathop{\rm Im}\nolimits} \{ {R_L}(\tau)\}\]</span></p><h2 id="平稳序列循环平稳">2.8平稳序列、循环平稳</h2><p>1）随机序列：无限个随机变量</p><ul><li>均值：<em>m(n)=E[Xn]，n</em>为整数</li><li>相关函数：</li></ul><p><span class="math display">\[{R_{XY} }(k,m) = E[{X_k}{Y_m}]\]</span></p><ul><li>不相关：对任意<em>k,m</em>有</li></ul><p><span class="math display">\[{R_{XY} }(k,m) = E[{X_k}{Y_m}] = E[{X_k}]E[{Y_m}]\]</span></p><ul><li>同一时刻不相关：对任意<em>k</em>有</li></ul><p><span class="math display">\[{R_{XY} }(k) = E[{X_k}{Y_k}] = E[{X_k}]E[{Y_k}]\]</span></p><p>2）广义平稳序列：<em>{Xn}</em> 的均值及自相关函数与绝对时间<em>n</em> 无关。</p><p>3）联合平稳：随机序列 <em>{Xn}</em> 与 <em>{Yn}</em>各自平稳且互相关函数与绝对时间 <em>n</em> 无关。</p><p>4）复平稳序列：复值随机序列 <em>{Zn}</em> 的实部及虚部联合平稳。</p><p>5）循环平稳过程：均值与自相关函数是 <em>t</em> 的周期函数</p><h2 id="高斯过程">2.9高斯过程</h2><p>1）Q函数的定义：标准正太分布大于上 <em>x</em> 分位数的概率。</p><p>2）erfc函数的定义：<em>X~N(0,1/2),</em>|<em>X</em>|<em>&gt;x</em>的概率</p><p>3）联合高斯</p><p><img src="https://s2.loli.net/2022/03/18/tUCVqDmBPfEGHW7.png" /></p><p>矩阵表示：</p><p><img src="https://s2.loli.net/2022/03/18/6zC1V5FLcEIjDNW.png" /></p><p>4）高斯过程：</p><p>设𝑋𝑡是随机过程，若对于任意𝑛个时刻 𝑡1,𝑡2,⋯,𝑡𝑛，𝑋𝑡1,𝑋𝑡2,⋯,𝑋(𝑡𝑛)服从联合高斯分布，则称𝑋𝑡为高斯过程。</p><p>5）当均值为0时，高斯随机变量的方差就是其功率。</p><h2 id="高斯白噪声">2.10高斯白噪声</h2><p>1）理想限带白高斯噪声</p><p><img src="https://s2.loli.net/2022/03/18/zOAbq8gpiYLueB3.png" /></p><p>2）高斯白噪声</p><p>高斯白噪声是理想限带高斯白噪声带宽B趋于无穷的极限。</p><ul><li>白噪声的自相关函数是一个冲击信号： <span class="math display">\[E[u(t + \tau )n(t)] = \frac{ { {N_0} } }{2}\delta (\tau )\]</span></li></ul><p>3）高斯白噪声通过滤波器</p><p><img src="https://s2.loli.net/2022/03/19/CIx93Uo7fkOq8nF.png" /></p><p>由于输入𝑛w(𝑡)是零均值平稳高斯过程，所以输出𝑛(𝑡)也是零均值平稳高斯过程。</p><p>输出𝑛(𝑡)的功率谱密度： <span class="math display">\[{P_n}(f) = \frac{ { {N_0} } }{2}{\left| {H(f)} \right|^2}\]</span> 输出𝑛(𝑡)的功率： <span class="math display">\[E[{n^2}(t)] = \int_{ - \infty }^\infty  {\frac{ { {N_0} } }{2}{ {\left|{H(f)} \right|}^2} } df = \frac{ { {N_0} } }{2}\int_{ - \infty}^\infty  { { {\left| {H(f)} \right|}^2} } df = \frac{ { {N_0} }}{2}{E_h}\]</span></p><h2 id="白高斯噪声与确定信号的内积">2.11白高斯噪声与确定信号的内积</h2><p>1）高斯白噪声与一个确定信号的内积</p><p><img src="https://s2.loli.net/2022/03/19/AaJPmrMtgzQvlWO.png" /></p><p>设𝑔(𝑡)是能量为𝐸𝑔的确定实能量信号。白高斯噪声𝑛w(𝑡)与𝑔(𝑡)的内积为：<span class="math display">\[Z = \int_{ - \infty }^\infty  { {n_w}(t)g(t)} dt\]</span> Z服从高斯分布，Z的均值是0，方差： <spanclass="math display">\[\begin{array}{l}\quad {\sigma ^2} = \frac{ { {N_0} } }{2}{E_g}\\\therefore Z \sim N(0,\frac{ { {N_0} } }{2}{E_g})\end{array}\]</span> 2）高斯白噪声与两个确定信号的内积</p><p><img src="https://s2.loli.net/2022/03/19/hHY5Xx7eQoz81A9.png" /><span class="math display">\[\begin{array}{l}{Z_1} \sim N(0,\frac{ { {N_0} } }{2}{E_1})\\{Z_2} \sim N(0,\frac{ { {N_0} } }{2}{E_2})\end{array}\]</span> Z1,Z2的相关性： <span class="math display">\[E[{Z_1}{Z_2}] = \frac{ { {N_0} } }{2}\int_{ - \infty }^\infty  { {\phi_1}(t)} {\phi _2}(t)dt\]</span> 若两个确定信号正交，则Z1,Z2独立。</p><p>3）高斯白噪声在归一化正交函数上的投影</p><p><img src="https://s2.loli.net/2022/03/19/KIGHZ4cq3SX5oB7.png" /></p><h2id="窄带高斯噪声的解析信号及复包络">2.12窄带高斯噪声的解析信号及复包络</h2><p>1）窄带高斯噪声𝑛(𝑡)：频谱无限宽的白高斯噪声𝑛w(𝑡)通过一个带通型滤波器𝐻(𝑓)后形成了𝑛(𝑡)。</p><p><img src="https://s2.loli.net/2022/03/19/fKLqZmnSy9NjYc4.png" /></p><p>2）n(t)希尔伯特变换的特性</p><ul><li>输出是零均值的平稳高斯过程；</li><li>输入输出有相同的自相关函数、功率谱密度、功率；</li><li>互相关函数是原自相关函数的希尔伯特变换，是奇函数； <spanclass="math display">\[{R_{\hat nn} }(\tau ) = {\hat R_n}(\tau )\quad \quad {R_{n\hat n} }(\tau) = {R_{\hat nn} }( - \tau ) =  - {\hat R_n}(\tau )\]</span></li><li>输入输出在同一时刻不相关</li></ul><p><span class="math display">\[{R_{n\hat n} }(0) = {R_{\hat nn} }(0) = 0\]</span></p><p>3）解析信号的性质同平稳带通过程相同</p><p>4）复包络的特性</p><ul><li>复包络是零均值复高斯过程</li><li>复包络功率谱密度</li></ul><p><span class="math display">\[{P_L}(f) = {P_Z}(f + {f_c}) = 4{P_n}(f + {f_c}),\quad \left| f \right|\le {f_c}\]</span></p><ul><li>复包络和解析信号有相同的功率</li></ul><p><span class="math display">\[{P_L} = {P_Z} = 2{P_n}\]</span></p><ul><li>复包络的自相关函数与解析信号的自相关函数相差一个指数项；共轭相关函数为0</li><li>复包络是复平稳过程，满足共轭不相关。</li><li>复包络的同相分量与正交分量有相同的自相关函数、功率谱密度、功率。</li></ul><p><span class="math display">\[\begin{array}{l}{P_c}(f) = {P_s}(f) = \frac{1}{4}{P_L}(f) + \frac{1}{4}{P_L}( - f)\\\quad \quad \quad \quad \quad \quad  = {P_n}(f + {f_c}) + {P_n}(f -{f_c}),\left| f \right| &lt; {f_c}\end{array}\]</span></p><ul><li>同相分量与正交分量独立</li></ul><h2 id="匹配滤波器">2.13匹配滤波器</h2><p><img src="https://s2.loli.net/2022/03/19/ksGXb4386Wy5Hrl.png" /></p><ul><li>瞬时信噪比：</li></ul><p><span class="math display">\[\gamma  = \frac{ { {y^2}({t_0})} }{ {E[{n^2}({t_0})]} }\]</span></p><p><strong>匹配滤波器，使𝑡0时刻的信噪比𝛾最大</strong></p><ul><li>根据柯西-施瓦兹不等式，可得最大信噪比𝛾：</li></ul><p><span class="math display">\[{\gamma _{\max } } = \frac{ {2{E_s} } }{ { {N_0} } }\]</span></p><ul><li>最佳滤波器（匹配滤波器）： s</li></ul><p><span class="math display">\[h(t) = K \cdot s({t_0} - t)\]</span></p><ul><li>匹配滤波器的传递函数：</li></ul><p><span class="math display">\[H(f) = K \cdot {S^*}(f){e^{ - j2\pi f{t_0} } }\]</span></p><ul><li>匹配滤波器输出波形是s(t)的自相关函数乘以K.</li></ul>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业论文排版教程（word）</title>
    <link href="/2022/03/15/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88%E6%95%99%E7%A8%8B%EF%BC%88word%EF%BC%89/"/>
    <url>/2022/03/15/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88%E6%95%99%E7%A8%8B%EF%BC%88word%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="毕业论文排版教程word">毕业论文排版教程（word）</h1><p>毕业论文乃是毕业前的最后一道关卡，一路过五关斩六将，总算把一万多字的论文码完了，你满心欢喜地给导数发去初稿，换来了一句“格式乱起八糟”，怎是一个愁字了得，这篇文章就是给大家解决问题。</p><p>word排版最重要的就是自动化，如果我们每次改动都需要大动全篇，这种机械的无意义的工作将会大量消磨人的时间和精力。本文主要为了便利我电学生快速完成毕业论文排版工作，博主制作了针对我电毕业论文格式的自动化模板，本文主要告诉大家如何正确使用此模板，如需深度探讨word排版，可通过关于页提供的邮箱联系博主。</p><p>毕业论文格式模板下载链接<strong>（包含Mathtype7安装包和补丁）</strong>：https://pan.baidu.com/s/1PuWyRaFiUt4cmLuNkFUTXg提取码：7777</p><p><img src="https://s2.loli.net/2022/03/15/xZhXtumDrkMpoF6.png" style="zoom:67%;" /></p><h2 id="样式">样式</h2><p>在这个模板里，几乎已经将毕业论文中所需用到的段落字体样式和编号都预设好了，需要什么格式直接选中该段落上，并点击相应的样式即可快速调整成想要的格式。若后期需要修改段落结构，只需修改相应的样式，即可批量修改应用该样式的所有文字。</p><p><img src="https://s2.loli.net/2022/03/15/US2ZN3JoOkvnX79.png" /></p><p>例如，我们想将绪论设置成一级标题（四号 黑体 20磅 段后0.5行）</p><p><img src="https://s2.loli.net/2022/03/15/6Ee4QKasfGLhxNd.jpg" /></p><h2 id="图片">图片</h2><p>在正文中插入图片，可能会出现下图这样只显示一部分的情况，这是由于正文的样式设置了固定20磅的行距，图片显示也只能显示20磅。</p><p><img src="https://s2.loli.net/2022/03/15/eL8r5OzkBhfuvxo.png" /></p><p>这时只需选中图片，再点击“图片”样式，就能将图片完整显示出来。后续使用Mathtype插入公式时，出现这种情况，选择“公式”样式即可。</p><p><img src="https://s2.loli.net/2022/03/15/fe6tbw42MzOqYPW.png" /></p><p>作为学术论文，每张插入的图片都需要插入题注，图片的题注一般位于图片的下方，鼠标右键点击图片，之后按下图的步骤创建图注，图注是论文中引用图片的标识，通过这种方法创建的图注可以在文章中交叉引用，在修改时可以自动编号。</p><p><img src="https://s2.loli.net/2022/03/15/fO5YVsjRSJpE3xn.jpg" /></p><p>创建好图注之后，会发现默认图注是在靠左侧，我们希望它居中，并且是自己希望的字体和大小，这时我们可以选中图注点击样式中的“图注”样式。</p><p><strong>正文中的图片引用：</strong>这是插入图片之后的一个关键操作，是实现自动编号的重中之重。</p><p>word中有个功能叫做“交叉引用”，“引用类型”选择题注中设置的标签：图；“引用类型”设置为：仅标签和编号；在“引用哪一个题注”处选择要引用的图注。</p><p><img src="https://s2.loli.net/2022/03/15/EflYh5iXU6CtGcZ.jpg" /></p><p>完成之后即可在需要引用的地方插入引用了。</p><p><img src="https://s2.loli.net/2022/03/15/HGAjXPRnNMrLOeK.png" /></p><p>这种方法插入的引用，在图片编号变化时，只需全选按F9更新宏，即可批量修改。并且这种方法还在引用处加了超链接，导出pdf版本后，可直接点击引用处即可快速跳转到图片的位置。</p><p>交叉引用还可插入：表的引用、章节的引用、参考文献的引用，方法相同。</p><h2 id="表格">表格</h2><p>表格如何插入就不讲了，主要说说学术上喜欢使用的三线表格类型。</p><p><img src="https://s2.loli.net/2022/03/15/iJzEFVMoOnR4b8c.png" /></p><p>word默认插入表格是下图这种类型：</p><p><img src="https://s2.loli.net/2022/03/15/Z7ClAE13GUxqSkR.png" /></p><p>可能是丑了点吧，学术大牛不太喜欢，学术大牛还是有些简约浪漫主义情调。</p><p><img src="https://s2.loli.net/2022/03/15/cjuGLC8HRZK4S9D.jpg" /></p><p>具体怎么调过于简单，这里就不详加叙述，只需选中一些格，将他们的边框隐藏或者显示，并调整成合适线宽。</p><p>表格同样需要添加题注和引用，方法如图片所述。</p><h2 id="公式">公式</h2><p>说到word中插入公式，不得不提Mathtype了，Mathtype7的安装和破解文件在文章开头的百度网盘链接中，有需要可自行下载安装，Mathtype还可以用于Latex公式的编写。</p><p>正常安装好Mathtype后，在word中会多一个Mathtype的插件，我们在论文中插入公式将使用到这个插件，之前安装Mathtype没有这个插件的，可以尝试使用博主提供安装包重新安装。</p><p><img src="https://s2.loli.net/2022/03/15/VbpB3ZkHqDLUglF.png" /></p><p>若需在文字中间加入公式的，可以点击“内联”；若需在单独的一行插入公式并且给公式编号的，可以点击“右编号”，之后将出现正常的Mathtype界面，编辑完成后关闭保存即可。</p><p>插入公式也不可避免的需要用到公式引用，公式的引用用到的就是Mathtype的插件了，前提条件是创建公式时选择“右编号”，已经添加了编号。如下图所示，在需要引用的位置选择“插入引用”后，就会出现加阴影的斜体“公式参考此处”，之后双击公式编号处，即可正确引用公式。</p><p><img src="https://s2.loli.net/2022/03/15/INFifvGz9Ml2r1J.jpg" /></p><p>编号更新也与图片编号引用相同，F9更新宏。同样，这样添加的引用加了超链接。</p><p><strong>公式这里再补充一点：</strong>在文字中插入公式后，修改该段落的格式，经常会出现公式偏上的情况，如下图，有时这种情况在论文中出现还不止一处。</p><p><img src="https://s2.loli.net/2022/03/15/dl8C1PI9rVAeogM.png" /></p><p>这时我们就可以使用Mathtype插件中的“格式化公式”，选择“整篇文档”，点击“确定”。</p><p><img src="https://s2.loli.net/2022/03/15/wXS8HaTC5cj4q7l.jpg" /></p><p>等一会之后，文章中所有的公式就全部更新好了。</p><p><img src="https://s2.loli.net/2022/03/15/5NZcnv67Si9WtGp.png" /></p><p><strong>Mathtype</strong>安装之后，word中可能会出现宏被禁用的情况<imgsrc="https://s2.loli.net/2022/03/16/KRD35qHxuCw7UAg.png" /></p><p>这时可参照下面这篇博客。</p><p><ahref="https://blog.csdn.net/tianyunzqs/article/details/51099057">word加载MathType打开时显示“安全警告，宏已被禁用”解决办法_tianyunzqs的博客-CSDN博客_mathtype宏已被禁用</a></p><h2 id="参考文献">参考文献</h2><p>参考文献的格式是导师们指出的重要问题了。</p><p>参考文献可以直接从知网或者谷歌学术中导出，如下图：</p><ul><li>中文（知网）<imgsrc="https://s2.loli.net/2022/03/15/JC2q1BKlItPsOnr.png" /></li><li>外文（谷歌学术）<imgsrc="https://s2.loli.net/2022/03/15/UGHKtTf4Zsqol6h.png" /></li></ul><p>将其复制到word中后，<imgsrc="https://s2.loli.net/2022/03/15/RjCb7NATdV86XwM.png" /></p><p>可以选择“参考文献”样式，调整其格式并且自动编号<imgsrc="https://s2.loli.net/2022/03/15/wj4bq9JOVdzRTZH.png" /></p><p>参考文献在论文中的引用同样需要用到“交叉引用”</p><p><img src="https://s2.loli.net/2022/03/15/xJSLRrYATI4ugEb.png" /></p><p>在需要引用的地方打开“交叉引用”窗口，“引用类型”选择：编号项；“引用内容”选择：段落编号（无上下文）；“引用哪一个编号项”选择需要引用的文献。</p><p><img src="https://s2.loli.net/2022/03/15/eRoxUZPuJaME6Km.jpg" /></p><p>添加交叉引用后会发现参考文献的标注不是右上角的小标，这时可以选中标注，点击开始-字体中的“上标”选项卡即可，同样全选按F9自动更新。</p><h2 id="目录">目录</h2><p>在正确设置好文字段落样式的前提下，直接全选按F9即可生成目录。</p><p><img src="https://s2.loli.net/2022/03/17/TBYXaGig8KRx1kV.png" /></p><p>目录更新后，会发现中英文“摘要”和“目录”都在目录里。这是因为博主把中英文“摘要”和“目录”也设置成了一级标题，这样设置的目的是为了使用AdobeAcrobat插件导出PDF时，能添加上中英文“摘要”和“目录”的书签。</p><p><img src="https://s2.loli.net/2022/03/17/ATMRJhr5wtPVHqm.png" /></p><p>直接选中中英文“摘要”和“目录”的目录行，按Delete删除即可。</p><h2 id="结语">结语</h2><p>上述方法可以适用大部分排版，但无法揽括所有情况，word有时会出现一些莫名其妙的问题。未尽事宜，欢迎共同探讨。</p>]]></content>
    
    
    <categories>
      
      <category>毕业论文排版</category>
      
    </categories>
    
    
    <tags>
      
      <tag>毕业论文排版</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理——第一章（确定信号分析）</title>
    <link href="/2022/03/12/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E7%A1%AE%E5%AE%9A%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2022/03/12/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E7%A1%AE%E5%AE%9A%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1id="通信原理第一章确定信号分析">通信原理——第一章（确定信号分析）</h1><h2 id="信号">1.1信号</h2><h3 id="信号的功率和能量">1.1.1信号的功率和能量</h3><p>信号𝑠(𝑡)一般表示电压𝑠随时间𝑡变化的函数。</p><p>信号𝑠(𝑡)的瞬时功率是s<sup>2(t)，信号𝑠(𝑡)在区间[t,t+a]内的能量是s</sup>2(t)·a，当a非常小时。</p><p><img src="https://s2.loli.net/2022/03/12/YKBujohvL6ybZc2.png" /></p><p>能量和功率满足以下性质：</p><ul><li>能量、功率非负</li><li>信号乘以实系数𝐾，能量或功率将乘以𝐾^2</li><li>时延不改变能量或功率</li><li>能量或功率一般不满足叠加性</li><li>两个不同频率的信号之和的功率是各自功率之和</li></ul><h3 id="复信号">1.1.2复信号</h3><p><strong>复信号：</strong>可以理解为一对实信号 <spanclass="math display">\[z(t) = a(t) + jb(t) = A(t){e^{j\varphi (t)} }\]</span> 复信号的瞬时功率是实部和虚部瞬时功率之和： <spanclass="math display">\[{\left| {z(t)} \right|^2} = {a^2}(t) + {b^2}(t)\]</span> ### 1.1.3复单频信号</p><p><strong>复单频信号：</strong>点在圆周上匀速运动，逆时针旋转是正转，顺时针旋转是反转；</p><p><img src="https://s2.loli.net/2022/03/12/9gupPXt6mcFkDdA.png" /></p><p>复单频信号的模平方与复指数部分无关。</p><p><img src="https://s2.loli.net/2022/03/12/xnw6Y4dzNT1EZ9G.png" /></p><h2 id="傅里叶变换">1.2傅里叶变换</h2><p>1）定义 <span class="math display">\[\begin{array}{*{20}{l} }{(1)\quad F(f) = \int_{ - \infty }^\infty  {f(t){e^{ - j 2\pi f t} } }dt =  &lt; f(t),{e^{j 2\pi f t} } &gt; }\\{(2)\quad f(t) = \int_{ - \infty }^\infty  {F(f){e^{j 2\pi f t} } }df  =  &lt; F(f),{e^{ - j 2\pi f t} } &gt; }\end{array}\]</span></p><p>2）性质</p><ul><li><p>一个域中的原点的值是另一个域中的面积</p></li><li><p>时域越宽，频域越窄；频域越宽，时域越窄；</p></li><li><p>时移、频移</p></li><li><p><imgsrc="https://s2.loli.net/2022/03/12/ODcPRsLzXwETnfM.png" /></p><p>实信号x(t)的频谱满足共轭偶对称</p><p><imgsrc="https://s2.loli.net/2022/03/12/8gFlnXTDxGozH6P.png" /></p></li><li><p><imgsrc="https://s2.loli.net/2022/03/12/IpZxtUAXoTe1mdR.png" /></p></li></ul><p>3）矩形的傅氏变换是sinc</p><p><img src="https://s2.loli.net/2022/03/14/3Azp5IHy9i2Sfba.png" /></p><p>4）sinc的傅氏变换是矩形</p><p><img src="https://s2.loli.net/2022/03/14/XeUCl1sTNE67Juq.jpg" /></p><p>要点：sinc前面乘的是矩形的面积，sinc()括号内𝑡或𝑓前乘的是矩形的宽度</p><h2 id="内积">1.3内积</h2><p>1）定义</p><p><img src="https://s2.loli.net/2022/03/12/cCFQuXJ26igh7qy.png" /></p><p>2）性质</p><ul><li>时域内积等于频域内积，则有时域正交频域也正交。<imgsrc="https://s2.loli.net/2022/03/13/3vGSrlJCpj4Vc2B.png" /></li><li>信号的能量是信号与自身的内积</li><li>帕瑟瓦尔定理，因此能量可以在时域计算，也可以在频域计算。<imgsrc="https://s2.loli.net/2022/03/13/IMY258WXSNJqaHR.png" /></li><li>互能量，两个信号的内积称为互能量，两个信号的互能量顺序不同，会导致结果也不相同。</li></ul><h2 id="许瓦兹不等式">1.4许瓦兹不等式</h2><ul><li>互能量的模值小于等于自能量的几何平均。</li></ul><p>柯西-施瓦茨不等式和数学中的不等式是一样的，可以扩展至多维的情况。</p><ul><li><p>能量归一化： <span class="math display">\[\frac{ {x(t)} }{ {\sqrt { {E_x} } } },\frac{ {y(t)} }{ {\sqrt { {E_y} }} }\]</span></p></li><li><p>能量归一化相关系数： <span class="math display">\[{\rho _{xy} } = \int_{ - \infty }^\infty  {\frac{ {x(t)} }{ {\sqrt {{E_x} } } } \cdot \frac{ { {y^*}(t)} }{ {\sqrt { {E_y} } } } } dt =\frac{ { {E_{xy} } } }{ {\sqrt { {E_x}{E_y} } } }\]</span></p></li></ul><h2 id="能量信号的相关函数">1.5能量信号的相关函数</h2><p>1）定义</p><p><img src="https://s2.loli.net/2022/03/13/fLkJ6goa1CHNew4.png" /></p><p>2）性质</p><ul><li>互相关函数的共轭对称性：</li></ul><p><span class="math display">\[{R_{xy} }(\tau ) = R_{yx}^*( - \tau )\]</span></p><ul><li>自相关函数共轭偶对称性：</li></ul><p><span class="math display">\[{R_{x} }(\tau ) = R_{x}^*( - \tau )\]</span></p><ul><li>x(t)的能量是自相关函数在自变量=0处的值</li></ul><h2 id="能量谱密度">1.6能量谱密度</h2><p>1）能量信号的互能量谱密度 <span class="math display">\[{E_{xy} }(f) = X(f){Y^*}(f)\]</span> 信号傅里叶变换的共轭乘积。</p><p>2）能量信号的自能量谱密度（能量谱密度） <span class="math display">\[{E_x}(f) = X(f){X^*}(f) = {\left| {X(f)} \right|^2}\]</span> 3）互相关函数的傅氏变换是互能量谱密度 <spanclass="math display">\[{R_{xy} }(\tau ) \Leftrightarrow X(f){Y^*}(f)\]</span> <imgsrc="https://s2.loli.net/2022/03/14/3wKRWHJIXarxdmf.png" /></p><h2 id="功率信号的相关函数">1.7功率信号的相关函数</h2><p>1）功率信号自相关函数</p><p><img src="https://s2.loli.net/2022/03/14/MrkROUetywHjQum.png" /></p><p>2）功率信号自相关函数与能量自相关函数相同</p><p>3）功率谱密度定义 <span class="math display">\[{P_{xy} }(f) = \mathop {\lim }\limits_{T \to \infty } \{\frac{1}{T}X(f){Y^*}(f)\}\]</span></p><h2 id="信号的带宽">1.8信号的带宽</h2><p>1）单边谱密度：实信号的能量或功率谱密度是𝑓的偶函数。</p><p>2）基带信号与频带信号</p><ul><li>基带信号也叫低通信号：信号的功率或能量主要集中在𝑓=0附近</li><li>频带信号也叫带通信号：信号的功率或能量主要集中在某个载频𝑓c附近</li></ul><p><strong>3）带宽</strong></p><ul><li>信号的带宽指单边谱密度的宽度</li><li>带宽有多种定义，主要有：</li></ul><p><img src="https://s2.loli.net/2022/03/15/6sMfBpoWhZ1txU9.png" /></p><ul><li>信号平方的带宽：x(t)平方的绝对带宽是x(t)的两倍</li></ul><h2 id="线性时不变系统">1.9线性时不变系统</h2><p>线性时不变系统也叫滤波器或简称为线性系统。</p><p><img src="https://s2.loli.net/2022/03/16/VTq9HCBx812Rfj3.png" /></p><p>𝐻(𝑓)是ℎ(𝑡)的傅氏变换。</p><p><img src="https://s2.loli.net/2022/03/16/qMZfgJUbtpWe7lx.png" /></p><ul><li>能量谱密度：</li></ul><p><span class="math display">\[{E_y}(f) = {\left| {H(f)} \right|^2}{E_x}(f)\]</span></p><ul><li>功率谱密度：</li></ul><p><span class="math display">\[{P_y}(f) = {\left| {H(f)} \right|^2}{P_x}(f)\]</span></p><ul><li>理想低通滤波器：传递函数是矩形，冲激响应是sinc函数</li></ul><p><img src="https://s2.loli.net/2022/03/16/eUYoIbX5pgBwFjh.png" /></p><h2 id="希尔伯特变换与解析信号">1.10希尔伯特变换与解析信号</h2><p>1）希尔伯特变换</p><p>实信号𝑥(𝑡)的希尔伯特变换^x(𝑡)是将𝑥(𝑡)通过一个特定滤波器的输出：<imgsrc="https://s2.loli.net/2022/03/16/yuJjLFtszo1R3w4.png" /></p><p>该滤波器的时域冲激响应是：<imgsrc="https://s2.loli.net/2022/03/16/x9eiVOIC2LG3wEF.png" /></p><p>频域传递函数是：<imgsrc="https://s2.loli.net/2022/03/16/JysFcYRq3geHxPu.png" /></p><p>2）性质：</p><ul><li>希尔伯特变换不改变能量谱密度，不改变功率谱密度。</li><li>偶函数的希尔伯特变换是奇函数，奇函数的希尔伯特变换是偶函数。</li><li>希尔伯特变换不改变功率。</li><li>希尔伯特变换后与原信号正交。</li></ul><p>3）解析信号：实信号𝑥(𝑡)的解析信号𝑧(𝑡)定义为如下复信号： <spanclass="math display">\[z(t) = x(t) + j \cdot \hat x(t)\]</span> <imgsrc="https://s2.loli.net/2022/03/16/U3DpAx9iNe7abWv.png" /></p><p>解析信号的传递函数： <span class="math display">\[H(f) = 1 + j \cdot [ - j \cdot {\mathop{\rm sgn}} (f)] = 1 +{\mathop{\rm sgn}} (f) = \left\{ \begin{array}{l}2,\quad f &gt; 0\\0,\quad f &lt; 0\end{array} \right.\]</span> 输出信号的频谱： <span class="math display">\[Z(f) = H(f)X(f) = \left\{ \begin{array}{l}2X(f),\quad f &gt; 0\\\quad 0,\quad \quad \,\,f &lt; 0\end{array} \right.\]</span></p><p>功率谱密度： <span class="math display">\[{P_z}(f) = {\left| {1 + {\mathop{\rm sgn}} (f)} \right|^2}{P_x}(f) =\left\{ \begin{array}{l}4{P_x}(f),\quad f &gt; 0\\\quad 0,\quad \quad \;f &lt; 0\end{array} \right.\]</span></p><h2 id="带通信号的复包络">1.11带通信号的复包络</h2><p>1）带通信号：带通信号是指频谱集中在某个载频𝑓c附近的信号。注意𝑓c不一定必须是信号频带的中心频率。</p><p>2）复包络的定义： <span class="math display">\[{x_L}(t) = z(t){e^{ - j2\pi {f_c}t}}\]</span> 其中，z(t)是x(t)的解析信号。</p><p>复包络的频谱： <span class="math display">\[{X_L}(f) = Z(f + {f_c}) = \left\{ {\begin{array}{*{20}{l}}{2X(f + {f_c}),\quad \left| f \right| &lt; {f_c}}\\{\quad 0,\quad \quad {\mkern 1mu} \quad \quad else}\end{array}} \right.\]</span> 复包络的功率谱密度： <span class="math display">\[{P_L}(f) = {P_Z}(f + {f_c}) = \left\{ {\begin{array}{*{20}{l}}{4{P_x}(f + {f_c}),\quad \left| f \right| &lt; {f_c}}\\{\quad 0,\quad \quad \;\quad \quad else}\end{array}} \right.\]</span></p><p><strong>复包络相当于把带通信号往左搬移到基带。</strong></p><p>从复包络的频谱推导出带通信号的频谱： <span class="math display">\[X(f) = \frac{1}{2}{X_L}(f - {f_c}) + \frac{1}{2}X_L^*( - f - {f_c})\]</span></p><h2 id="带通信号的表示">1.12带通信号的表示</h2><p>复包络一般是一个复信号，可以写成实部、虚部这样的直角坐标形式，也可以写成模值、相角这样的极坐标形式。<span class="math display">\[{x_L}(x) = {x_c}(x) + j \cdot {x_s}(x) = A(t){e^{j\varphi (t)}}\]</span> <imgsrc="https://s2.loli.net/2022/03/16/6wDzBPZEVAT4X5x.png" /></p><p><strong>带通信号的三种表示方式：</strong></p><p><img src="https://s2.loli.net/2022/03/16/zEUygole14PBn7X.png" /></p><h2 id="带通系统的等效基带分析">1.13带通系统的等效基带分析</h2><p>1）带通系统</p><p><img src="https://s2.loli.net/2022/03/16/VTq9HCBx812Rfj3.png" /></p><p>带通信号通过带通系统变成了另外一个带通信号。带通系统的传递函数𝐻(𝑓)是带通型的，其冲激响应ℎ(𝑡)是一个带通信号。</p><p>2）等效基带系统</p><p><img src="https://s2.loli.net/2022/03/26/ysb7Hmj24JMoi5G.png" /></p><p>带通信号𝑥(𝑡)通过带通滤波器ℎ(𝑡)后变成了另一个带通信号𝑦(𝑡)，此问题可等价地看成是：复包络𝑥L(𝑡)通过一个等效基带系统ℎe(𝑡)后变成了另一个复包络𝑦L(𝑡)。</p><p><img src="https://s2.loli.net/2022/03/16/NVu2LAXDOpecnJr.png" /></p><p>等效替代后系统的传递函数是原系统的传递函数往下搬移fc的频率。</p>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统——第四章（频谱分析技术应用）</title>
    <link href="/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%88%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%EF%BC%89/"/>
    <url>/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%88%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1id="信号与系统第四章频谱分析技术应用">信号与系统——第四章（频谱分析技术应用）</h1><h2 id="信号调制与解调">4.1信号调制与解调</h2><h3 id="调制解调基本概念">4.1.1调制解调基本概念</h3><p>便于信号在信道中传播。</p><p><img src="https://s2.loli.net/2022/03/10/NvRA5DX8wOlJHpr.png" /></p><p><img src="https://s2.loli.net/2022/03/10/l8MyQ5YO73Bdma6.png" /></p><h3 id="正弦调制和复指数调制">4.1.2正弦调制和复指数调制</h3><p>1）正弦调制</p><p><img src="https://s2.loli.net/2022/03/10/3woJSgr5I9XTKRN.png" /></p><p>载波抑制调制（存在相位转换点）：</p><p><img src="https://s2.loli.net/2022/03/10/GbnNP8oLJfgQ56T.png" /></p><p>普通调制（原信号添加一个直流分量）：</p><p><img src="https://s2.loli.net/2022/03/10/v9jYqbinzyPGDc8.png" /></p><p>2）复指数调制</p><p>使用复指数载波信号进行调制：</p><p><img src="https://s2.loli.net/2022/03/10/MNQey85Gv9zpHra.png" /></p><p>正弦调制后，存在两个波形；而复指数调制后，只有一个波形，可以避免出现频谱混叠的现象。</p><p><img src="https://s2.loli.net/2022/03/10/gZ5ORvpHQrfwXSi.png" /></p><h3 id="单边带幅度调制">4.1.3单边带幅度调制</h3><p>单边带，只取信号的一边频带，可以节省信号发送的能量和带宽。</p><p><img src="https://s2.loli.net/2022/03/10/T6DSEhWIcgn8PMt.png" /></p><p>1）滤波法：采用高通和低通滤波器，获取单边带。</p><p>2）移相法：</p><p><img src="https://s2.loli.net/2022/03/11/iZCvW5Pw4eRpuL1.png" /></p><h3 id="信号的解调">4.1.4信号的解调</h3><p>1）同步解调</p><p><img src="https://s2.loli.net/2022/03/11/i4QteaNljCZ68Rk.png" /></p><p>载波信号初始相位为0，在调制后的信号上再乘以载波信号，经过三角变换，可分离出原信号。在波形上表示为调制后的信号频谱两部分分别左右移，在原点处重合部分即为原信号。</p><p><strong>当初始相位不为0时：</strong> <span class="math display">\[\begin{array}{l}w(t) = y(t)\cos {\omega _c}t = f(t)\cos ({\omega _c}t + \theta )\cos{\omega _c}t\\\quad \quad  = f(t)[\frac{ {\cos \theta  + \cos (2{\omega _c}t + \theta)} }{2}]\end{array}\]</span> 2）包络线解调</p><p>要求原信号采用普通调制。</p><h3 id="实际应用">4.1.5实际应用</h3><p><strong>1）信道的复用</strong></p><p><img src="https://s2.loli.net/2022/03/11/umpksW6HAaGfzKb.png" /></p><p>码分复用分别使用正弦和余弦调制，解调时也对应使用正弦和余弦，由于正弦和余弦相位相差90°，所以不会相互干扰。</p><p><img src="https://s2.loli.net/2022/03/11/arNSpgxsd6BuKhX.png" /></p><p><strong>CDMA：</strong>相互正交的伪随机码，和正弦、余弦作用相当，解调时不会相互影响。</p><p><img src="https://s2.loli.net/2022/03/11/hqfVDnpS5YlFMu3.png" /></p><p><strong>2）脉冲编码调制技术PCM</strong></p><p><img src="https://s2.loli.net/2022/03/11/4N26jZOCaiDIrz9.png" /></p><h2 id="信号的采样与恢复">4.2信号的采样与恢复</h2><h3 id="离散性与周期性的对应关系">4.2.1离散性与周期性的对应关系</h3><ul><li>时域理想采样：使用周期采样脉冲信号调制</li></ul><p>周期采样脉冲信号的频谱是周期为w的采样脉冲信号，原信号使用周期采样脉冲信号调制，则调制后的信号频谱是原信号与周期为w的采样脉冲信号的卷积。</p><p><img src="https://s2.loli.net/2022/03/11/xw5qEOs9rKWiyv2.png" /></p><p>信号采样离散化，频谱周期延拓，形成周期信号，周期正好是采样信号的频率。</p><ul><li>自然采样：使用周期矩形信号采样</li></ul><p><img src="https://s2.loli.net/2022/03/11/ZqCSnx3DdtuvGNB.png" /></p><h3 id="采样定理">4.2.2采样定理</h3><p><img src="https://s2.loli.net/2022/03/11/ioxykcLTvmUrKEJ.png" /></p><p>唯一恢复条件：</p><p><img src="https://s2.loli.net/2022/03/11/2hUWvnks1jaOVrL.png" /></p><p>信号频率的两倍称为奈奎斯特（Nyquist）频率。当采样频率大于奈奎斯特（Nyquist）频率时，采样后的频谱没有重叠，可以通过滤波器得到原始信号。</p><h3 id="欠采样系统">4.2.3欠采样系统</h3><p>欠采样可以通过一个高频信号获得低频信号，当出现混叠后，频率会出现降低的现象。</p><h3 id="信号重建">4.2.4信号重建</h3><p>理论上可以通过低通滤波器得到原始信号，但实际中存在两个问题：Sa(t)函数是一个非因果信号；恢复信号包含无数多项叠加。</p><p>所以需要采用近似算法恢复原信号，如零阶保持、一阶保持。</p>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在公共服务器上使用非root用户离线安装tensorflow-gpu 2.x</title>
    <link href="/2022/03/10/%E5%9C%A8%E5%85%AC%E5%85%B1Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85tensorflow-gpu/"/>
    <url>/2022/03/10/%E5%9C%A8%E5%85%AC%E5%85%B1Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85tensorflow-gpu/</url>
    
    <content type="html"><![CDATA[<h1id="在公共服务器上使用非root用户离线安装tensorflow-gpu-2.x">在公共服务器上使用非root用户离线安装tensorflow-gpu2.x</h1><p>非root用户还是离线安装tensorflow-gpu很少有这么苛刻的条件，这偏偏被我遇上了。。。</p><p>场景是这样的，老师给了我一个超算的用户，这种学校的公共服务器肯定是不会给root权限的，而偏偏这台机器只连学校内网，这就很郁闷。。。</p><p>在网上查了查很少有这样场景下的安装教程，于是我就来写一篇。</p><h2 id="一寻常做法">一、寻常做法</h2><p>因为离线，所以寻常做法是通过命令复制现有的base环境</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda create tf_gpu -clone base<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>在自己电脑里下载python、tensorflow-gpu，以及所有依赖库，把它们都上传到服务器上一个一个安装，不出所料我吐了。</p><p>于是经过我百般摸索，使出了浑身解数，终于给我发现了一个神奇的方法。</p><h2 id="二借助虚拟机安装">二、借助虚拟机安装</h2><p>这起源于，我从百度上得知conda创建的虚拟环境可以直接复制到另一台机器上使用。</p><p>我在我自己的笔记本上创建了一个和服务器ubuntu版本一样的虚拟机（虚拟机的安装过程我这里就不叙述了）。在服务器上，通过conda-V命令我得到了服务器上conda的版本是4.10.3，于是我在虚拟机上也同样安装了一个conda4.10.3。于是我在虚拟机上，安装寻常安装tensorflow的步骤：</p><p>创建虚拟环境。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda create -n tf_gpu Python&#x3D;3.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>激活虚拟环境。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">activate tf-gpu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>安装tensorflow-gpu，这样所需要的依赖就可以自动安装。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda install tensorflow-gpu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>网上说要使用gpu加速，需要另外装cuda和cudnn两个工具，而cuda和cudnn有很严格的版本对应关系，因为担心会冲突，我先用conda安装cudatoolkit、cudnn</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda install cudatoolkitconda install cudnn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>这样我就得到了cuda版本11.3.1和cudnn版本8.2.1（不知道我这样是否多此一举，但我确是这样做了），后续下载相应的版本进行安装。</p><p><img src="https://s2.loli.net/2022/02/12/TseURp37FrJNWjD.png" /></p><p>注意：以上安装过程均未使用root权限。</p><p>把前面这些能在虚拟机中安装好的完成之后，开始将tf_gpu打包，使用cd命令切换至虚拟环境目录，打包虚拟环境tf_gpu</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zcvf tf_gpu.tar.gz tf_gpu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>将tf_gpu.tar.gz复制上传至服务器。</p><p>将tf_gpu.tar.gz解压至服务器conda的虚拟环境目录</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zxvf tf_gpu.tar.gz -C ～&#x2F;.conda&#x2F;envs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这里每个人的conda虚拟环境目录可能会不同，请根据自己的实际情况而定。</p><p>解压之后，在终端中输入conda info-e就会发现tf_gpu已经迁移到服务器中了。</p><p><img src="https://s2.loli.net/2022/02/12/L3oe91xKldTjXJz.png" /></p><p>激活tf_gpu虚拟环境</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">activate tf_gpu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>进入python环境</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tfa <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>可以正常输出，但会报一堆警告，这是因为还需要安装cuda和cudnn。</p><h2 id="三cuda安装">三、cuda安装</h2><p>到NVIDIA官网 <ahref="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.nvidia.com%2Fcuda-toolkit-archive">[CUDAToolkit Archive | NVIDIADeveloper](https://developer.nvidia.com/cuda-toolkit-archive)</a>选择对应版本的cuda，这里选择11.3.1。</p><p>然后再选对应的系统型号和installer type</p><p><img src="https://s2.loli.net/2022/02/12/yQBxj1aoU5OGILl.png" /></p><p>将“BaseInstaller”里面的下载链接复制到下载器中，或者也可以自己复制链接地址用wget下载，然后安装</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;compute&#x2F;cuda&#x2F;11.3.1&#x2F;local_installers&#x2F;cuda_11.3.1_465.19.01_linux.run# sh后的文件名以实际下载文件名为准sh cuda_11.3.1_465.19.01_linux.run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>因为是非root用户，所以安装过程中所以需要root权限的操作都要避免掉。</p><p>接受协议</p><p><img src="https://s2.loli.net/2022/02/12/8Kqpe5LWDuFfrcw.png" /></p><p>取消cuda安装驱动程序</p><p><img src="https://s2.loli.net/2022/02/12/W3C26owX1KPBRd7.png" /></p><p>进入Options</p><p><img src="https://s2.loli.net/2022/02/12/9E84ftDTvN3L1oR.png" /></p><p>不更新和安装驱动</p><p><img src="https://s2.loli.net/2022/02/12/uyEtc69XA7OgFdY.png" /></p><p>不创建链接和文档</p><p><img src="https://s2.loli.net/2022/02/12/DzuqixQXkce8Sfp.png" /></p><p>更改cuda的安装路径为用户目录</p><p><img src="https://s2.loli.net/2022/02/12/qyM1DjgrCAL3NVR.png" /></p><p>更改完这些选项就可以安装了。</p><h2 id="四cudnn安装">四、cudnn安装</h2><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNNArchive | NVIDIA Developer</a>下载cudnn需要NVIDIA账号，注册一个即可。</p><p>选择对应cuda版本号的cudnn版本（8.2.1）。</p><p><img src="https://s2.loli.net/2022/02/12/wbcT2ovR7UCxJSg.png" /></p><p>选择cuDNN Library forLinux，因为下载cudnn是需要登录的，所以在自己电脑上下载后，再传到服务器上。</p><p>下载完 cuDNN，发现后缀是 .tgz ，使用命令解压至用户目录</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tar -zxvf cudnn-11.3-linux-x64-v8.2.1.32.tgz -C ~&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>解压后发现cudnn总共分两个目录，复制 cuDNN 文件到 CUDA安装目录：(cuDNN 解压到 ~/cuda 目录了，~/cuda-11.3 为自己设定的 CUDA安装目录，~ 代表用户目录),并且给所有用户添加读的权限</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cp ~&#x2F;cuda&#x2F;include&#x2F;cudnn.h ~&#x2F;cuda-11.3&#x2F;includecp ~&#x2F;cuda&#x2F;lib64&#x2F;lib* ~&#x2F;cuda-11.3&#x2F;lib64chmod a+r ~&#x2F;cuda-11.3&#x2F;include&#x2F;cudnn.h ~&#x2F;cuda-11.3&#x2F;lib64&#x2F;libcudnn*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>建立软连接</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ~&#x2F;cuda-11.3&#x2F;lib64ln -sf libcudnn.so.8.2.1 libcudnn.so.8ln -sf libcudnn.so.8 libcudnn.soldconfig -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="五配置用户环境变量">五、配置用户环境变量</h2><p>修改 ~/.bashrc 文件，将下面两行加进去：（将xxx 改成自己的用户名）</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">export PATH&#x3D;&#x2F;home&#x2F;xxx&#x2F;cuda-11.3&#x2F;bin$&#123;PATH:+:$&#123;PATH&#125;&#125; export LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;wuliyttaotao&#x2F;cuda-11.3&#x2F;lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>保存 ~/.bashrc 文件后，source ~/.bashrc 使其生效。</p><p>到这一步tensorflow-gpu的环境搭建就完成了，我们可以验证一下是否启动了GPU加速。在python中运行下面代码，打印结果若是true，则成功启动GPU加速，反之。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">print</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>test<span class="token punctuation">.</span>is_gpu_available<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p><strong><em>温馨提示：</em></strong>使用公共服务器的同学可以在安装自己的cuda和cudnn后，最好删除安装文件，为自己和别人节省公共空间。（安装其他包也是一样，及时清理安装缓存文件）</p><h2 id="reference">reference</h2><p><a href="https://www.jianshu.com/p/c95c5b6a4707">Linux服务器中非 root用户安装（多版本） CUDA 和 cuDNN - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
      <tag>cuda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统——第三章（信号的频谱分析）</title>
    <link href="/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1id="信号与系统第三章信号的频谱分析">信号与系统——第三章（信号的频谱分析）</h1><h2 id="正交函数集合">3.1正交函数集合</h2><h3 id="正交的定义">3.1.1正交的定义</h3><p>对于定义的某种内积运算，两个函数在该运算下的结果为0，这两个函数正交。</p><p>定义内积运算： <span class="math display">\[\int_{ - \infty }^{ + \infty } {f(x)g(x)dx}  = 0\]</span></p><h3 id="正交函数集合-1">3.1.2正交函数集合</h3><p>有n个函数构成的一个函数集合，在区间内满足两两正交关系，则称为正交函数集合。若函数的模为1，则称为归一化正交函数集合。</p><p>正交函数分解：smith变换。</p><h3 id="完备正交函数集合">3.1.3完备正交函数集合</h3><p>完备可以理解为，正交函数集合中的函数是函数的线性空间中的一组基。</p><p>正经定义1：如果在正交函数集之外不存在有限能量且能量不为0的函数与函数集中任何函数都正交。（其实就是正交基的概念）</p><p>正经定义2：任何函数f(t)分解成正交函数集的线性组合，它们之间的误差的能量：<span class="math display">\[\begin{array}{l}e(t) = f(t) - \sum\limits_{i = 1}^n { {c_i}{g_i}(t)} \\\left\| {e(t)} \right\|_2^2 = 0\end{array}\]</span></p><h3 id="完备正交基的例子">3.1.4完备正交基的例子</h3><p>1）三角函数： <span class="math display">\[\{ \cos n{\omega _1}t,\sin n{\omega _1}t\} ,n = 0,1,2,...,\infty\]</span> 2）复指数函数： <span class="math display">\[\{ {e^{jn{\omega _1}t} }\} ,n = 0, \pm 1, \pm 2,..., \pm \infty\]</span> 傅里叶变换： <span class="math display">\[\begin{array}{l}f(t) = {a_0} + \sum\limits_{n = 1}^\infty  {({a_n}\cos n{\omega _1}t +{b_n}\sin n{\omega _1}t)} \\\quad \quad  = \sum\limits_{n =  - \infty }^\infty  { {F_n}{e^{jn{\omega_1}t} } }\end{array}\]</span></p><h3id="三角函数复指数集合的完备正交性">3.1.5三角函数/复指数集合的完备正交性</h3><p>1）三角函数</p><p><img src="https://s2.loli.net/2022/02/20/E68UfXke1nwaqM4.png" /></p><p>2）复指数函数</p><p><img src="https://s2.loli.net/2022/02/20/hWSdc8NLKeGCTyi.png" /></p><h3 id="parseval定理">3.1.6 Parseval定理</h3><p><span class="math display">\[\begin{array}{l}P = \overline { {f^2}(t)}  = \frac{1}{ { {T_1} } }\int_{ {t_0} }^{ {t_0}+ {T_1} } { {f^2}(t)dt} \\\quad  = a_0^2 + \frac{1}{2}\sum\limits_{n = 1}^\infty  {(a_n^2 +b_n^2)} \\\quad  = \sum\limits_{n =  - \infty }^\infty  { { {\left| { {F_n} }\right|}^2} }\end{array}\]</span></p><h2 id="周期信号的傅里叶级数分解">3.2周期信号的傅里叶级数分解</h2><h3 id="分解公式">3.2.1分解公式</h3><p>1）三角函数分解形式</p><p><img src="https://s2.loli.net/2022/02/20/4OtbBRS7nJaYQ12.png" /></p><p>一个信号可以分解为一个直流信号与无穷多个交流信号的叠加，其中与原信号周期相同的交流信号称为信号的<em>基波</em>，其他交流信号称为信号的<em>谐波</em>。</p><p>2）复指数分解形式</p><p>复指数函数通过欧拉公式，可化成三角函数形式，相当与复指数函数分别在实轴和虚轴上的投影。</p><p><img src="https://s2.loli.net/2022/02/20/rlfxoW75dkVhjAR.png" /></p><p>参数对应关系：</p><p><img src="https://s2.loli.net/2022/02/20/Ffe6sw1bWKhdqrA.png" /></p><h3 id="周期矩阵信号的分解">3.2.2周期矩阵信号的分解</h3><p>1）三角函数分解</p><p>信号的幅度图：</p><p><img src="https://s2.loli.net/2022/02/20/yQJjg9AM5SHVwPq.png" /></p><p>信号的相位图：</p><p><img src="https://s2.loli.net/2022/02/20/OWm2RYGnXFIuB5v.png" /></p><p>2）复指数分解</p><p><img src="https://s2.loli.net/2022/02/20/8ZlyORLMKq5cdgH.png" /></p><h3 id="级数收敛条件">3.2.3级数收敛条件</h3><p>在高等数学中，傅里叶级数收敛条件是有有限个第一类间断点即可。</p><p>1）能量条件：能量有限</p><p>2）波形条件（Dirichlet条件）</p><ul><li>信号一个周期内绝对可积</li><li>极大值极小值个数有限</li><li>间断点个数有限</li></ul><p><strong>Gibbs现象：</strong></p><p><img src="https://s2.loli.net/2022/02/20/6jhIYHkfBX85Z7W.png" /></p><h2 id="典型周期信号傅里叶级数分解">3.3典型周期信号傅里叶级数分解</h2><h3 id="典型信号">3.3.1典型信号</h3><p>1）周期方波信号：实偶函数<imgsrc="https://s2.loli.net/2022/03/08/RmVpiCDeMyKJN69.png" /></p><p>1中Sa(t)抽样函数随谐波次数n衰减；2中当n为偶数时，an=0，这样的函数称为奇谐函数。</p><p>2）周期锯齿信号：实奇函数，</p><p><img src="https://s2.loli.net/2022/03/08/sb2JjZdfWYvgEhC.png" /></p><p>3）三角脉冲信号</p><p><img src="https://s2.loli.net/2022/03/08/9oq5VhJAEz4NS2w.png" /></p><p>连续，高频分量更少，谐波分量衰减更快，奇谐信号</p><p>4）半波余弦信号：实偶函数</p><p><img src="https://s2.loli.net/2022/03/08/v3wBWQZmDURYkC6.png" /></p><p>5）全波整流余弦信号</p><p><img src="https://s2.loli.net/2022/03/09/BUSNKXlFYfVI9dH.png" /></p><p>6）周期脉冲序列：白色频谱，高频分量丰富，功率发散信号，单位脉冲信号功率无穷大</p><p><img src="https://s2.loli.net/2022/03/08/CmbJwie28Q3uNyg.png" /></p><p><strong>傅里叶级数分解的频谱规律：</strong></p><p><img src="https://s2.loli.net/2022/03/08/xMIVtmaQ5274wSP.png" /></p><h3 id="信号的对称性">3.3.2信号的对称性</h3><p>1）偶对称</p><p>2）奇对称</p><p>3）奇谐对称：只存在奇次谐波，偶次谐波不存在</p><p><img src="https://s2.loli.net/2022/03/09/WtOSuX51hVyTLni.png" /></p><p>将波形移动半个基波周期，结果与原来相反。</p><h3 id="信号参数与频谱的关系">3.3.3信号参数与频谱的关系</h3><p>1）矩形脉冲信号</p><p><img src="https://s2.loli.net/2022/03/08/HFVlE58bmGMvsqA.png" /></p><p><strong>频谱的幅值：</strong>表示谐波的功率</p><p>当周期无穷大时，频谱变成了幅值为0的连续频谱；当周期为脉冲宽度时，这信号只包含直流分量，高频分量频谱在包络线的零点处。</p><p><strong>频带宽度：</strong>（频谱主半宽度） <spanclass="math display">\[B \approx \frac{ {2\pi } }{\tau }\quad \quad B \propto \frac{1}{\tau }\]</span> 频谱消失： <span class="math display">\[{\omega _1} = \frac{m}{n}\frac{ {2\pi } }{\tau }\]</span></p><h2 id="傅里叶变换">3.4傅里叶变换</h2><h3 id="推导过程">3.4.1推导过程</h3><p><strong>FT公式：</strong>（1）正变换；（2）负变换。积分内的指数函数部分呈共轭关系。<span class="math display">\[\begin{array}{*{20}{l} }{(1)\quad F(\omega ) = \int_{ - \infty }^\infty  {f(t){e^{ - j\omega t}} } dt =  &lt; f(t),{e^{j\omega t} } &gt; }\\{(2)\quad f(t) = \frac{1}{ {2\pi } }\int_{ - \infty }^\infty  {F(\omega){e^{j\omega t} } } d\omega  =  &lt; F(\omega ),{e^{ - j\omega t} } &gt;}\end{array}\]</span> 频谱间隔随周期变化而变换</p><p><img src="https://s2.loli.net/2022/03/09/Fh6xDG3PKpMyQ4g.png" /></p><p>正变换公式推导，幅度由表示功率转化成表示能量： <spanclass="math display">\[\begin{array}{l}{T_1} \cdot F(n{\omega _1}) = \int_{ - \frac{ { {T_1} } }{2} }^{\frac{ {{T_1} } }{2} } {f(t){e^{ - jn{\omega _1}t} } } dt\\\frac{0}{0} = \frac{ {2\pi F(n{\omega _1})} }{ { {\omega _1} } } =F(\omega ) = \int_{ - \infty }^\infty  {f(t){e^{ - j\omega t} } } dt\end{array}\]</span> F(w)表示频谱密度函数，简称频谱函数。</p><p>负变换公式推导：（卓晴老师的课件有点小问题，下图已更正）</p><p><img src="https://s2.loli.net/2022/03/08/FySCPgGBMuzH781.png" /></p><p>从周期信号的离散谐波分解得到非周期信号的频谱密度函数。</p><p><strong>对称性质：</strong></p><p><img src="https://s2.loli.net/2022/03/08/SVjFNOxPJg5pf7e.png" /></p><h3 id="对称性分析">3.4.2对称性分析</h3><p><img src="https://s2.loli.net/2022/03/08/9zJSwH5rPQfTML1.png" /></p><p>傅里叶变换的特征函数：</p><p><img src="https://s2.loli.net/2022/03/09/vshK3OxkPzHu165.png" /></p><h3 id="广义傅里叶变换">3.4.3广义傅里叶变换</h3><p>1）存在条件</p><p><img src="https://s2.loli.net/2022/03/09/3ApeiLZolNUWmFH.png" /></p><p>2）广义傅里叶变换</p><p><img src="https://s2.loli.net/2022/03/09/Hq9tX3CBG6JYyuA.png" /></p><h3 id="证明过程">3.4.4证明过程</h3><p><img src="https://s2.loli.net/2022/03/09/GfzVL2jiXCHRTKF.png" /></p><h2 id="典型信号傅里叶变换">3.5典型信号傅里叶变换</h2><h3 id="公式法求ft">3.5.1公式法求FT</h3><p><strong>FT公式：</strong>（1）正变换；（2）负变换。积分内的指数函数部分呈共轭关系。<span class="math display">\[\begin{array}{*{20}{l} }{(1)\quad F(\omega ) = \int_{ - \infty }^\infty  {f(t){e^{ - j\omega t}} } dt =  &lt; f(t),{e^{j\omega t} } &gt; }\\{(2)\quad f(t) = \frac{1}{ {2\pi } }\int_{ - \infty }^\infty  {F(\omega){e^{j\omega t} } } d\omega  =  &lt; F(\omega ),{e^{ - j\omega t} } &gt;}\end{array}\]</span></p><h3 id="广义傅里叶变换方法">3.5.2广义傅里叶变换方法</h3><p><img src="https://s2.loli.net/2022/03/09/XHCpDOqaTzU3ZIW.png" /></p><h3 id="奇偶虚实与共轭对称性">3.5.3奇偶虚实与共轭对称性</h3><p>1）奇偶虚实：当信号是纯实的偶函数时，频谱是纯实的偶函数；当信号是纯实的奇函数时，频谱是纯虚的，在频域内关于w的奇函数；当信号是纯虚的偶函数时，结论奇偶性对调。</p><p><img src="https://s2.loli.net/2022/03/09/keSLPca3xDCpz6d.png" /></p><p>信号的奇偶分解分别对应于频谱的虚部和实部，通过逆变换可以可以从频谱的虚部和实部分别求出信号的奇偶分量。</p><p><img src="https://s2.loli.net/2022/03/09/7Q3Jb5CvMmgKz9T.png" /></p><p>2）共轭对称性</p><p><img src="https://s2.loli.net/2022/03/09/GbXr8wEi6Y9CsAT.png" /></p><h3 id="信号的频谱衰减">3.5.4信号的频谱衰减</h3><p>1）光滑性与频谱衰减有关：波形不连续，频谱衰减与w成反比；波形连续，导数不连续，频谱衰减与w的平方成反比；波形连续，导数连续，频谱衰减与w的3次方成反比；</p><p><img src="https://s2.loli.net/2022/03/09/2SecTWhHnjgz4ME.png" /></p><p><img src="https://s2.loli.net/2022/03/09/a348Nkr2wTuL6Us.png" /></p><p><strong>高斯信号是FT的特征信号，其具有信号和频谱都快速衰减的特点。</strong></p><h2 id="傅里叶变换的性质一">3.6傅里叶变换的性质（一）</h2><p><img src="https://s2.loli.net/2022/03/09/cSIjv5X3u2CAbLW.png" /></p><h3 id="线性特性">3.6.1线性特性</h3><p><img src="https://s2.loli.net/2022/03/09/CAO5ZFvLEoWml4a.png" /></p><h3 id="比例变换特性">3.6.2比例变换特性</h3><p><img src="https://s2.loli.net/2022/03/09/hkwEFrDidmp6sSf.png" /></p><p><strong>等效脉冲宽度与频带宽度：</strong></p><p><img src="https://s2.loli.net/2022/03/09/ZAmyGS2F3oqtpTP.png" /></p><p>等效脉冲宽度与频带宽度的乘积是一个常量，频带宽度就是信号的带宽。</p><p>信号宽度的度量方式：</p><p><img src="https://s2.loli.net/2022/03/15/FUVu5JOkjHQ1Xtf.png" /></p><h3 id="时移特性">3.6.3时移特性</h3><p><img src="https://s2.loli.net/2022/03/10/6puAtNqyc2zVhkF.png" /></p><h3 id="频移特性">3.6.4频移特性</h3><p><img src="https://s2.loli.net/2022/03/09/uwC7o2q6JKQOGfz.png" /></p><p>平移相当于信号的幅度调制。</p><p>正弦信号的调制分析：</p><p><img src="https://s2.loli.net/2022/03/09/wA5QEFdhix7Cc2n.png" /></p><h2 id="傅里叶变换的性质二">3.7傅里叶变换的性质（二）</h2><h3 id="微分特性">3.7.1微分特性</h3><p>微分与线性加权通过傅里叶变换联系起来。 <span class="math display">\[F[\frac{ { {d^n} } }{ {d{t^n} } }f(t)] = {(j\omega )^n}F(\omega )\]</span> <imgsrc="https://s2.loli.net/2022/03/09/YmKzkIAvEFU8ojC.png" /></p><p>时域微分和频域微分：</p><p><img src="https://s2.loli.net/2022/03/09/6MXh9yq3Jplk4Tv.png" /></p><p>运用：</p><p><img src="https://s2.loli.net/2022/03/09/rM5Gz63AVWOZc2o.png" /></p><h3 id="积分特性">3.7.2积分特性</h3><p><img src="https://s2.loli.net/2022/03/09/2QTbncH4fsoEAmN.png" /></p><p>当F(0)=0时，冲击信号部分为0，则FT变换的积分、微分可以相互运算。F(0)=0有以下情况：</p><ul><li>f(t)：奇函数；有限长函数的导数。</li></ul><p><img src="https://s2.loli.net/2022/03/10/ExIoGwkuZyJM2Xp.png" /></p><h3 id="卷积特性">3.7.3卷积特性</h3><p><img src="https://s2.loli.net/2022/03/10/RkxQuKpgHeXF3Pd.png" /></p><p><strong>系统频率响应（系统幅频函数）：</strong></p><p><img src="https://s2.loli.net/2022/03/10/f5bwBF6qLYEshrP.png" /></p><h3 id="测不准原理">3.7.4测不准原理</h3><p><img src="https://s2.loli.net/2022/03/10/Tn26qLHKIxdYl7V.png" /></p><h2 id="周期信号ft">3.8周期信号FT</h2><h3 id="傅里叶级数分解">3.8.1傅里叶级数分解</h3><p><img src="https://s2.loli.net/2022/03/10/GOFiPIsTgrwvY9b.png" /></p><h3 id="卷积方法">3.8.2卷积方法</h3><p><img src="https://s2.loli.net/2022/03/10/YgVfQlaIemjONtM.png" /></p>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统——第二章（时域系统分析）</title>
    <link href="/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88%E6%97%B6%E5%9F%9F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88%E6%97%B6%E5%9F%9F%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1id="信号与系统第二章时域系统分析">信号与系统——第二章（时域系统分析）</h1><p><img src="https://s2.loli.net/2022/02/16/S8K9TmxprO5bsoV.png" /></p><h2 id="微分方程与差分方程">2.1微分方程与差分方程</h2><h3 id="微分方程的建立">2.1.1微分方程的建立</h3><p>以输出信号的导数的最高阶次，作为微分方程的阶次。微分方程根据物理的实际问题建立输入输出关系，例如电路系统，根据元器件的电气特性建立微分方程。</p><p><img src="https://s2.loli.net/2022/02/17/AOqx5ngbUShmLF6.png" /></p><p>一般把输出写在方程的左边，输入写在方程的右边。</p><h3 id="差分方程的建立">2.1.2差分方程的建立</h3><p>常用后向差分方程，以输出信号的最大延迟作为差分方程的阶。</p><p><img src="https://s2.loli.net/2022/02/17/AqGijdJagRoZp9e.png" /></p><p>1）微分方程离散化：使用前向差分或后向差分近似微分。</p><p>2）物理系统建立差分方程。</p><p>3）根据系统框图建立差分方程。</p><h3 id="方程求解">2.1.3方程求解</h3><p>建立微分/差分方程数学模型，求解输入输出的隐式关系成显式关系，并通过结果介绍其中物理含义。</p><p><img src="https://s2.loli.net/2022/02/17/IVml4wCsJTrASUE.jpg" /></p><p>根据微分/差分方程的齐次方程的特征方程，求出带待定系数的齐次解，</p><p><img src="https://s2.loli.net/2022/02/17/w2VkeYozj6qitup.png" /></p><p>求出微分/差分方程的一个特解，</p><p><img src="https://s2.loli.net/2022/02/17/e2RYrvcVX4BoCZA.png" /></p><p>根据初始条件确定方程中的未知参数。</p><h2 id="确定系统初始条件">2.2确定系统初始条件</h2><p><img src="https://s2.loli.net/2022/02/17/IDX7FHxJewjTv2O.png" /></p><h3 id="物理条件约束方法">2.2.1物理条件约束方法</h3><p>根据系统的实际物理特性确定，这处老师讲解的例子需要运用到电容电感的电路知识，这里我将题目列出，感兴趣的朋友可以试一试。</p><p><img src="https://s2.loli.net/2022/02/17/aoj234TkxqfYXO6.png" /></p><p>0时刻之前开关S在1处，0时刻将开关S拨向2处，求0+时刻通过电阻R1的电流。</p><h3 id="奇异函数匹配方法">2.2.1奇异函数匹配方法</h3><p>例如将函数y(t)分解成一个连续函数+单位冲激偶函数+单位冲激函数+单位跃迁函数<span class="math display">\[y(t){|_{ {0_ - } \sim {0_ + } } } = {y_1}(t) + a\delta &#39;(t) +b\delta (t) + c\Delta u(t)\]</span> 求y(t)在0-到0+之间的跳变， <span class="math display">\[y({0_ + }) - y({0_ - }) = c\]</span>应为只有单位跃迁函数在0处出现了跳变。所以计算整体跳变时，仅计算单位跃迁函数部分即可。</p><p>例子：</p><p><img src="https://s2.loli.net/2022/02/17/pWKk8usZPFQmXDg.png" /></p><p>博主真迹：</p><p><img src="https://s2.loli.net/2022/02/17/sZXleNL5F2GkSPJ.png" /></p><h3 id="迭代方法差分方程">2.2.1迭代方法：差分方程</h3><p><img src="https://s2.loli.net/2022/02/17/asLqfgP2QoFmtdE.png" /></p><h3 id="系统初始条件的两种特殊情况">2.2.1系统初始条件的两种特殊情况</h3><ul><li>零状态：对于连续时间系统，表示0-时各阶输出导数都是0；对于离散时间系统，表示n&lt;0时系统输出都是0.</li><li>零输入：系统在0时刻没有输出，当然系统状态没有跳变。</li></ul><h2 id="方程求解的举例说明">2.3方程求解的举例说明</h2><h3 id="连续时间信号例题">2.3.1连续时间信号例题</h3><p>例1：</p><p><img src="https://s2.loli.net/2022/02/18/fazwZv1sAM9VJj2.png" /></p><h3 id="离散时间信号例题">2.3.2离散时间信号例题</h3><p>有些离散时间信号例题的求解有点像组合数学中，递推关系的求解方法。</p><p>例2：</p><p><img src="https://s2.loli.net/2022/02/18/5U1YEqHKL7jnVkg.png" /></p><p>例3：<imgsrc="https://s2.loli.net/2022/02/18/YOAFWa3wLsZJS12.png" /></p><p>例4：</p><p><img src="https://s2.loli.net/2022/02/18/iLYXEOx7MuWzT4a.png" /></p><p>因为x[0]=0，是0输入，所以可以直接用y[-1]=-1求待定系数。</p><h3 id="银行贷款例题">2.3.3银行贷款例题</h3><p><img src="https://s2.loli.net/2022/02/18/f2dTgZD6BjQuGUH.png" /></p><p><img src="https://s2.loli.net/2022/02/18/Agm8lVQM4e3tCJ1.png" /></p><h3 id="差分方程数值求解微分方程">2.3.4差分方程数值求解微分方程</h3><p>对微分方程离散化，用差分代替微分操作：（后向差分形式） <spanclass="math display">\[\frac{ {dy(t)} }{ {dt} } = \frac{ {y(nT) - y(nT - T)} }{T}\]</span> <imgsrc="https://s2.loli.net/2022/02/18/aJtjwc94oNUlD5n.png" /></p><h3id="奇异函数平衡法求解初始条件">2.3.5奇异函数平衡法（求解初始条件）</h3><p>同2.2.1节奇异函数匹配法。</p><p><img src="https://s2.loli.net/2022/02/18/ACPfyxb1lWThS7w.png" /></p><h2 id="lti系统解的分析">2.4LTI系统解的分析</h2><h3 id="自由响应与强迫响应">2.4.1自由响应与强迫响应</h3><p>1）自由响应：齐次解 ——&gt;&gt;系统固有频率 <spanclass="math display">\[\sum\limits_{i = 1}^n { {c_i}{e^{ {\lambda _i}t} } } ,\sum\limits_{i =1}^N { {A_i}{a_i}^n}\]</span>如果系统是稳定的自由响应通常是瞬态解。自由响应总体形式与输入信号无关，但参数与输入信号有关。</p><p>2）强迫响应：特解 ——&gt;&gt;与激励函数形式有关系 <spanclass="math display">\[B(t),B[n]\]</span> 如果输入是稳定信号强迫响应也是稳态响应。</p><p><img src="https://s2.loli.net/2022/02/19/z9QDLlY4hcEkijX.png" /></p><p>系统的自由响应反映了系统的性质；系统的强迫响应反映了系统对信号的处理能力。</p><h3 id="瞬态解与稳态解">2.4.2瞬态解与稳态解</h3><p>1）瞬态解：当时间趋于无穷，系统输出趋于0的部分。</p><p>2）稳态解：当时间趋于无穷，保留下来的部分。</p><p><img src="https://s2.loli.net/2022/02/19/lKZ7RUfF8kc3O4L.png" /></p><h3 id="零输入响应与零状态响应">2.4.3零输入响应与零状态响应</h3><p>1）零输入响应：系统在没有外部输入信号的情况下，由内部起始条件所产生的响应。</p><p>2）零状态响应：系统在起始条件为零的情况下的系统对于输出信号的输出响应。</p><h3 id="单位冲击与阶跃响应介绍">2.4.4单位冲击与阶跃响应介绍</h3><p>1）单位冲击响应：LTI输入为单位冲击信号时的零状态响应，h(t),h[n]</p><p>2）单位阶跃响应：LTI输入为单位阶跃信号时的零状态响应，g(t),g[n] <spanclass="math display">\[\begin{array}{l}g&#39;(t) = h(t)\\g[n] - g[n - 1] = h[n]\end{array}\]</span> <strong>求解例题：</strong></p><p><img src="https://s2.loli.net/2022/02/19/GyvT1IY3gHnUea2.png" /></p><p><img src="https://s2.loli.net/2022/02/19/h3kzFm9M5NYQZRi.png" /></p><p><img src="https://s2.loli.net/2022/02/19/yTGikClhZvoe4BM.png" /></p><p><strong>注意：</strong>齐次解只是代表了t&gt;0之后的解，对于t=0的时刻，还需要判断是否包含了一些冲激信号。</p><p><img src="https://s2.loli.net/2022/02/19/3eFMp5vaIocxLTb.png" /></p><h3id="lti系统特性与单位冲击信号的关系">2.4.5LTI系统特性与单位冲击信号的关系</h3><p><img src="https://s2.loli.net/2022/02/19/RZO7Mt3IB4FdsK5.png" /></p><h2 id="卷积与卷积和">2.5卷积与卷积和</h2><h3 id="卷积的定义">2.5.1卷积的定义</h3><p><img src="https://s2.loli.net/2022/02/19/BE4nr1vIeyAZc2g.png" /></p><p>h(t),h[t]为系统的单位冲击响应。</p><p>卷积运算的条件：</p><ul><li>线性时不变系统LTI</li><li>求解LTI的零状态响应</li></ul><h3 id="卷积的性质">2.5.2卷积的性质</h3><p>1）代数性质</p><ul><li>交换性</li><li>分配律</li><li>结合律</li></ul><p>2）微分/差分 <span class="math display">\[\frac{d}{ {dt} }[{f_1}(t)*{f_2}(t)] = {f_1}(t)*\frac{d}{ {dt} }{f_2}(t)= \frac{d}{ {dt} }{f_1}(t)*{f_2}(t)\]</span> 3）积分/累加 <span class="math display">\[\int_{ - \infty }^t {[{f_1}(\tau )*{f_2}(\tau )]d\tau }  ={f_1}(t)*\int_{ - \infty }^t { {f_2}(\tau )d\tau }  = \int_{ - \infty}^t { {f_1}(\tau )d\tau } *{f_2}(t)\]</span></p><p>4）时移性质</p><p><img src="https://s2.loli.net/2022/02/19/ATVy9OfUlLEnJM8.png" /></p><p>5）与单位冲激信号、单位阶跃信号卷积</p><p><img src="https://s2.loli.net/2022/02/19/RXz62IwcPYCSkTu.png" /></p><p>与单位冲激信号卷积体现采样特性；同单位跃迁信号卷积体现为积分。</p><h3 id="性质的应用">2.5.3性质的应用</h3><p>利用性质2）微分/差分、3）积分/累加简化卷积运算：对一个卷积运算可以对其中一个信号进行微分使其称为一个单位冲激响应信号的加，再对另外一个信号进行积分，即可通过平移和相加得到卷积结果。</p><p><img src="https://s2.loli.net/2022/02/19/SpDekj7MJsitIAv.png" /></p><h3 id="辅助求解方法">2.5.4辅助求解方法</h3><p>1）图解法（通用方法）</p><p>2）对位相乘求和、表格方法、矩阵方法（离散）</p><p><img src="https://s2.loli.net/2022/02/19/bVmzxgWTaIUelYX.png" /></p><p>3）对连续时间信号离散化求解</p><h3 id="解卷积">2.5.5解卷积</h3><p>输入、卷积结果、系统单位冲激响应信号，知其二求其一。</p><p>例：x[n],y[n]求：h[n]—&gt;系统辨识；</p><p>​ h[n],y[n]求：x[n]—&gt;信号估计，信号恢复；</p><p>应用：图像恢复、雷达探测等。</p><h3 id="卷积的应用">2.5.6卷积的应用</h3><p>1）滤波：去噪、均衡、补偿</p><p>图像滤波，采用不同的滤波算子进行卷积达到不同的图像滤波效果。</p>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统——第一章（系统）</title>
    <link href="/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E7%B3%BB%E7%BB%9F%EF%BC%89/"/>
    <url>/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="信号与系统第一章系统">信号与系统——第一章（系统）</h1><h2 id="系统建模">1.7系统建模</h2><h3 id="系统的数学函数表示">1.7.1系统的数学函数表示</h3><p>描述系统输入输出的隐含关系，常用微分和查分方式表示。</p><h3 id="系统的框图表示">1.7.2系统的框图表示</h3><p>使用表示系统框图基本单元串、并联的方式表示</p><p><img src="https://s2.loli.net/2022/02/15/PZFzhil7nS8kNoB.png" /></p><p><strong>注意掌握：系统框图—&gt;系统方程的转换</strong></p><h3 id="子系统互联">1.7.3子系统互联</h3><p><img src="https://s2.loli.net/2022/02/15/DKxwq4gdtC5FpR8.png" /></p><h2 id="系统分类">1.8系统分类</h2><h3 id="连续离散时间系统">1.8.1连续、离散时间系统</h3><p>1）连续时间系统：输入、输出都是模拟连续信号。</p><p>2）离散时间系统：输入、输出都是离散信号。</p><p>3）使用离散时间系统处理连续时间信号：</p><p><img src="https://s2.loli.net/2022/02/15/cpZDbnQWB9MYAi4.png" /></p><h3 id="即时系统与动态系统">1.8.2即时系统与动态系统</h3><p>1）即时系统：无记忆系统，系统的输出只与系统的输入有关，使用代数方程描述。</p><p>2）动态系统：记忆系统，系统的输出与该时刻以外的输入也有关，如反馈联接，使用微分（差分）方程描述。</p><p>3）恒等系统：属于无记忆系统的一种特例，输出与输入相同。</p><h3 id="稳定系统与不稳定系统">1.8.3稳定系统与不稳定系统</h3><p>1）稳定系统：当输入有界时，输出有界。</p><p>2）不稳定系统：当输入有界时，输出无界。</p><h3 id="时变与时不变系统">1.8.4时变与时不变系统</h3><p>1）时不变系统：当输入信号有一个时移时，输出信号也产生同样的时移，但波形不会发生变化。</p><p>2）时变系统：当输入信号有一个时移时，输出波形会发生变化。</p><h3 id="可逆与不可逆系统">1.8.5可逆与不可逆系统</h3><p>如果一个系统对任何不同的输入都能产生不同的输出，即输入与输出是一一对应的则称该系统为可逆系统；否则称为不可逆系统。（类似与函数是否可逆）</p><h3 id="因果系统与非因果系统">1.8.6因果系统与非因果系统</h3><p>如果一个系统在任何时刻的输出都只与当时这个时刻的输入以及以前的输入有关，而和该时刻以后的输入无关，则称该系统是因果系统；否则就是非因果系统。</p><p>因果信号：当自变量t&lt;0时，因变量x(t)=0.</p><h3 id="线性与非线性系统">1.8.7线性与非线性系统</h3><p>满足叠加性(1)和齐次性(2)的系统称为线性系统，即具有线性性质： <spanclass="math display">\[\begin{array}{l}{x_1}(t) \to {y_1}(t),{x_2}(t) \to {y_2}(t),\\{x_1}(t) + {x_2}(t) \to {y_1}(t) + {y_2}(t)\quad\quad (1),\\a{x_1}(t) \to a{y_1}(t)\quad\quad\quad\quad\quad\quad\quad (2)\end{array}\]</span> 其中a是常数。</p><p><strong>线性系统的优势：</strong>利用系统的线性特性，可以将复杂信号分解成简单信号的叠加，分别求出简单信号的响应后再获得复杂信号的系统响应。</p><p>齐次性与叠加性相互独立，不一定同时满足。在实数系统中，满足叠加性则满足齐次性。</p><p><strong>增量线性系统：</strong>系统响应可分解为零状态响应和零输出响应（可分性）；零状态响应与输入成线性关系；零输入响应与状态成线性关系。</p><h3 id="局部线性系统与局部线性化">1.8.8局部线性系统与局部线性化</h3><p>1）局部线性系统：当系统的输入在一定区间内为线性系统，或者增量线性系统。</p><p>2）局部线性化：将信号函数泰勒展开为一阶线性函数，忽略高阶项。</p><h2 id="lti研究方法">LTI研究方法</h2><p>主要分为在时域和变换域两个方面进行研究，二者都是利用系统的时不变特性，通过信号的分解来研究信号的输出。</p><p><img src="https://s2.loli.net/2022/02/16/n6oYQ5cwMZdW8Ps.png" /></p>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不懂音乐，但想学吉他的拨弦手</title>
    <link href="/2022/03/10/%E4%B8%8D%E6%87%82%E9%9F%B3%E4%B9%90%EF%BC%8C%E4%BD%86%E6%83%B3%E5%AD%A6%E5%90%89%E4%BB%96%E7%9A%84%E6%8B%A8%E5%BC%A6%E6%89%8B/"/>
    <url>/2022/03/10/%E4%B8%8D%E6%87%82%E9%9F%B3%E4%B9%90%EF%BC%8C%E4%BD%86%E6%83%B3%E5%AD%A6%E5%90%89%E4%BB%96%E7%9A%84%E6%8B%A8%E5%BC%A6%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="不懂音乐但想学吉他的拨弦手">不懂音乐，但想学吉他的拨弦手</h1><p>吉他有六根弦，靠手拨动弦使其震动，产生声音的输入信号后，在共鸣腔形成的系统中放大输出，使人耳听到响亮悦耳的吉他声。（用信号与系统中的术语描述）</p><h2 id="小小乐理知识十二平均律">小小乐理知识（十二平均律）</h2><p><img src="https://s2.loli.net/2022/02/17/rzsJho6UeLAPnpK.png" /></p><p>例1和2中间隔了一个半音，而3和4没隔半音。<strong>记忆方法：</strong>全全半全全全半</p><p>数字1，2，3，4，5，6，7，1代表do，re，mi，fa，so，la，xi，do</p><p>每个弦音的位置都不一样，吉他六根弦从粗到细分别是：</p><ul><li>6弦··············E（3）mi</li><li>5弦··············A（6）la</li><li>4弦··············D（2）re</li><li>3弦··············G（5）so</li><li>2弦··············B（7）xi</li><li>1弦··············E（3）mi</li></ul><p>其它音根据空弦音往后推算。</p><h2 id="基本调音方法">基本调音方法</h2><h3 id="使用调音器调音">使用调音器调音</h3><ul><li>6弦··············E（3）mi</li><li>5弦··············A（6）la</li><li>4弦··············D（2）re</li><li>3弦··············G（5）so</li><li>2弦··············B（7）xi</li><li>1弦··············E（3）mi</li></ul><p>吉他六根弦空弦分别代表上面这些音，将每根弦弹出来的音在调音器上的显示与之对应。</p><h3 id="标准调弦">55545（标准调弦）</h3><p>吉他弦从上到下分别分为1,2,3,...,20品，对应20个格子。</p><p>从上面的6弦和5弦开始：</p><ul><li>6弦的第五品与5弦空弦音音高相同</li><li>5弦的第五品与4弦空弦音音高相同</li><li>4弦的第五品与3弦空弦音音高相同</li><li>3弦的第四品与2弦空弦音音高相同</li><li>2弦的第五品与1弦空弦音音高相同</li></ul><p>听不出音高（比如说我），可以看两根弦是否产生共振，相同音高才会产生共振，我仔细一看还真有！但是要是我两根弦都是乱的又该如何呢。。。</p><h3 id="傻瓜式调音方法">傻瓜式调音方法</h3><p>经过我苦心搜索，还是被我发现了一种傻瓜式调音方法，我在我平板上下载了一个GuitarTuna，就是下图这个</p><p><img src="https://s2.loli.net/2022/02/17/5nTGLQpaCdIRPof.png" style="zoom: 25%;" /></p><p>只需波动吉他弦，软件会提示要调高还是调低，终于很简单的我调好了我手上的这把吉他。</p><p><img src="https://s2.loli.net/2022/02/17/RltBMEsPekDxXof.png" /></p><p><strong>转播一条小姐姐的温馨提示：</strong>调音时脸不要贴的太近，万一调着调着弦断了呢。</p><h2 id="吉他识谱">吉他识谱</h2><h3 id="六线谱">六线谱</h3><p><img src="https://s2.loli.net/2022/02/18/fbnKOA9mVCUE5NG.jpg" /></p><p>六线谱从上到下分别代表吉他的六根弦，线上的数字表示该弦上的品数。</p><h3 id="和弦谱">和弦谱</h3><p><img src="https://s2.loli.net/2022/02/18/n1UaXPL45IjhVq6.png" /></p><p>和弦谱上圈中符号与手指的对应关系：1（食指）、2（中指）、3（无名指）、4（小指）、T（大拇指）。</p><p>上图中的黑色长条是一个食指大横按，第一行格子左边的1表示和弦谱从第一品开始，顶上的×表示这一根弦不弹。</p><h3 id="右手拨弦">右手拨弦</h3><p>大拇指波动6、5、4弦，食指挑动3弦，中指挑2弦，无名指挑1弦。</p><p>右手灵活的练习，43231323（博主的手指太笨了）</p><p><img src="https://s2.loli.net/2022/02/18/T1Z5PE8Q4pkxswg.png" /></p><h3 id="左手按弦">左手按弦</h3><p>手指尽量垂直，用指尖接触琴弦。</p><p><strong>爬格子训练</strong>。指短琴长，博主加油不能放弃！！！！</p><h2 id="常用音阶图">常用音阶图</h2><p><img src="https://s2.loli.net/2022/02/19/hctYXqFjiLxwr3M.jpg" /></p><h2 id="节拍">节拍</h2><p><img src="https://s2.loli.net/2022/02/19/ZKLaPn91D26QxJO.jpg" /></p><h3 id="拍子">拍子</h3><p>在音乐中，时间被分成均等的基本单位，每个单位叫做一个“拍子”或称一拍。拍子的时值是以音符的时值来表示的，一拍的时值可以是四分音符（即以四分音符为一拍），也可以是二分音符（以二分音符为一拍）或八分音符（以八分音符为一拍）。拍子的时值是一个相对的时间概念，比如当乐曲的规定速度为每分钟60 拍时，每拍占用的时间是一秒，半拍是二分之一 秒；当规定速度为每分钟 120拍时，每拍的时间是半秒，半拍就是四分之一秒，依此类推。拍子的基本时值确定之后，各种时值的音符就与拍子联系在一起。例如，当以四分音符为一拍时，一个全音符相当于四拍，一个二分音符相当于两拍，八分音符相当于半拍，十六分音符相当于四分之一拍；如果以八分音符做为一拍，则全音符相当于八拍，二分音符是四拍，四分音符是两拍，十六分音符是半拍。</p><h3 id="小节">小节</h3><p>音乐总是由强拍和弱拍交替进行的，这种交替不能杂乱无章、任意安排，而是按照一定的规律构成最小的节拍组织一小节，然后以此为基础循环往复。比如，当两个强拍之间只有一个弱拍时称作“二拍子”，2/4 节拍就是这种类型；当两个强拍之间有二个弱拍时称作“三拍子”，象 3/4 和 3/8；两个强拍之间有三个弱拍称“四拍子”，常见的是4/4。两个小节之间用“小节线”隔开。小节线是一条与谱表垂直的细线，上顶五线，下接一线，正好将谱表切断，无论上、下加线离开谱表多么远，小节线都不能超出谱表之外。作品的最后一个小节画两条小节线，并且右面的一条较粗一些，表示一部作品或一个段落的结束。小节线后面的那一拍一定是强拍，并且，每个小节只有一个强拍，其余均为弱拍。</p><h2 id="小姐姐教学视频">小姐姐教学视频</h2><p><ahref="https://www.bilibili.com/video/BV1c7411t7dR">「保姆级吉他零基础教学」入门吉他只需两周！</a></p>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统——第一章（信号）</title>
    <link href="/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/"/>
    <url>/2022/03/10/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="信号与系统第一章信号">信号与系统——第一章（信号）</h1><p><img src="https://s2.loli.net/2022/02/14/n54G9cLAhdE3BDQ.png" /></p><p>信号的定义：信号是传递、表达信息（消息）的物质载体。</p><p>系统的定义：特定功能的整体，有输入有输出。</p><h2 id="如何描述信号">1.1如何描述信号</h2><h3 id="连续时间信号">1.1.1连续时间信号</h3><p>1）函数表示 function <span class="math display">\[f(t) = k\sin (\omega t + \theta )\]</span> 2）图形、波形 waveform</p><p><img src="https://s2.loli.net/2022/02/14/8fCzNcs9ebTDZ5q.png" /></p><h3 id="离散时间信号">1.1.2离散时间信号</h3><p>1）函数表示</p><p>指数衰减序列 <span class="math display">\[f[n] = k{e^{ - 0.15n} },n = 0,1,2,3,...\]</span> 正弦震荡序列 <span class="math display">\[x[n] = 3\cos [\frac{ {4\pi n} }{ {25} }],n = 0,1,2,3,...\]</span> 2）序列波形</p><p><img src="https://s2.loli.net/2022/02/14/lUpzV4v2PftQCce.png" /></p><p>3）列表表示</p><p><img src="https://s2.loli.net/2022/02/14/4r2fxWXvZjIAybn.png" /></p><p>信号取值按自变量从小到大罗列出来</p><p><img src="https://s2.loli.net/2022/02/14/kdUPMphLAF3cyqG.png" /></p><p>答：三维函数对应的波形有函数表示和图像表示，更高维函数着只能通过函数表示。</p><p><img src="https://s2.loli.net/2022/02/14/VhkT96rPeHMtSRO.png" /></p><p>答：更高维的函数无法绘制出波形。</p><h2 id="如何手工描述信号">1.2如何手工描述信号</h2><p><img src="https://s2.loli.net/2022/02/14/wzfRoTLnKFiWpOU.png" /></p><h2 id="信号的分类">1.3信号的分类</h2><h3 id="确定性信号与随机信号">1.3.1确定性信号与随机信号</h3><p>实际信息传递过程中，包含了确定信号和随机信号。（伪随机信号、混沌信号）</p><h3 id="模拟信号与数字信号">1.3.2模拟信号与数字信号</h3><p>1）时间连续，幅值连续</p><p><img src="https://s2.loli.net/2022/02/14/47hWVUbnZBADvHs.png" /></p><p>2）时间离散，幅值连续</p><p><img src="https://s2.loli.net/2022/02/14/SqiBzcWyFJf7YKA.png" /></p><p>3）时间连续，幅值离散</p><p><img src="https://s2.loli.net/2022/02/14/bD1jGELOQUHt7x5.png" /></p><p>4）时间离散，幅值离散</p><p><img src="https://s2.loli.net/2022/02/14/4Ar1vTEdHPK9VUe.png" /></p><h3id="信号的能量与功率能量信号功率信号">1.3.3信号的能量与功率（能量信号、功率信号）</h3><p>1）信号的能量：(代表信号的强弱) <span class="math display">\[\begin{array}{l}E = \int_{ - \infty }^{ + \infty } { { {\left| {f(t)} \right|}^2}dt} \\E = \sum { { {\left| {x[n]} \right|}^2} } \qquad ({L^2} - Norm)\\\left| {a + jb} \right| = \sqrt { {a^2} + {b^2} }\end{array}\]</span> 能量信号：能量有限，平方可积 <span class="math display">\[E &lt;  + \infty ,P = 0.\]</span> 2）信号的功率：（一段时间内信号的平均能量） <spanclass="math display">\[\begin{array}{l}P = \mathop {\lim }\limits_{T \to \infty } \frac{1}{T}\int_{ -\frac{T}{2} }^{\frac{T}{2} } { { {\left| {f(t)} \right|}^2}dt} \\P = \mathop {\lim }\limits_{N \to \infty } \frac{1}{ {2N + 1} }\sum { {{\left| {x[n]} \right|}^2} }\end{array}\]</span> 功率信号：功率有限 <span class="math display">\[E =  + \infty ,P &gt; 0.\]</span> 3）能量为0的信号：信号有限个个离散点</p><p>4）能量发散、功率发散信号</p><h3 id="周期信号与基本周期">1.3.4周期信号与基本周期</h3><p><span class="math display">\[\begin{array}{l}f(t + T) = f(t)\\f[n + N] = f[n]\end{array}\]</span></p><p>1）基本周期：最小的T,N称为周期信号的基本周期。</p><p>2）两种特殊情况：</p><p><img src="https://s2.loli.net/2022/02/14/exJ3rZ9MRgO68KH.png" /></p><p>3）两个周期信号的复合</p><p><img src="https://s2.loli.net/2022/02/14/kh5avTMxqgES8Ul.png" /></p><p>4）信号复合与分解中的周期性不保持</p><p><img src="https://s2.loli.net/2022/02/14/QeUHsvVylpJthgb.png" /></p><p><img src="https://s2.loli.net/2022/02/14/RL6nUG9lPtVAkDr.png" /></p><h2 id="典型信号">1.4典型信号</h2><h3id="lti特征函数线性时不变系统">1.4.1LTI特征函数（线性时不变系统）</h3><p>信号在微分、积分操作下，函数形式保持不变。</p><p>1）指数信号、正弦信号</p><p><img src="https://s2.loli.net/2022/02/14/Aw8zy2v7JPYcgxG.png" /></p><p><em>2）复指数信号</em></p><p><img src="https://s2.loli.net/2022/02/14/caFSEHn7GUL2VlJ.png" /></p><h3 id="对称信号">1.4.2对称信号</h3><p>1）高斯信号</p><p>通常用于描述随机信号的分布密度函数，是傅里叶变换的特征函数。</p><p>2）抽样信号 <span class="math display">\[f(t) = Sa(t) = \frac{ {\sin (t)} }{t}\]</span> 函数在Π的整数倍数时过零点；1/t为衰减包络线。</p><h3 id="奇异信号">1.4.3奇异信号</h3><p>函数本身或者其导数存在不连续的信号。</p><p>1）单位斜变信号 <span class="math display">\[f(t) = \left\{ \begin{array}{l}t\quad t \ge 0\\0\quad t &lt; 0\end{array} \right.\]</span> 2）单位阶跃信号 <span class="math display">\[u(t) = \left\{ {\begin{array}{*{20}{l} }{1\quad t &gt; 0}\\{0\quad t &lt; 0}\end{array} } \right. = \frac{ {df(t)} }{ {dt} }\]</span> <em>性质：</em></p><ul><li>表示信号的起始/结束：延迟信号与反褶</li></ul><p>3）单位冲激信号 <span class="math display">\[\delta (t) = \left\{ \begin{array}{l}+ \infty \quad t = 0\\0\quad \;\;\;\;t \ne 0\end{array} \right. = \frac{ {du(t)} }{ {dt} }\]</span> <em>性质：</em></p><ul><li><p>抽样特性 <span class="math display">\[\int_{ - \infty }^{ + \infty } {\delta (t)f(t)dt = } \int_{ - 0}^{ + 0}{\delta (t)f(0)dt = } f(0)\]</span> 这里可以理解为积分第一中值定理。</p></li><li><p>偶对称</p></li><li><p>尺度特性 <span class="math display">\[\int_{ - \infty }^{ + \infty } {\delta (at)f(t)dt = } \int_{ - \infty}^{ + \infty } {\delta (\tau )f(\frac{\tau }{a})d\frac{\tau }{a} = }\frac{1}{a}f(0)\]</span></p></li><li><p>对持续时间短、瞬时作用信号的近似</p></li></ul><p>4）单位冲激偶信号 <span class="math display">\[\delta &#39;(t) = \frac{ {d\delta (t)} }{ {dt} }\]</span></p><h2 id="信号的运算">1.5信号的运算</h2><h3 id="运算介绍">1.5.1运算介绍</h3><p>时移、反转、尺度变换、微分、积分、卷积、相关</p><p><img src="https://s2.loli.net/2022/02/14/gIPxhnmaNWAfzoB.png" /></p><ul><li><p>卷积： <span class="math display">\[f(t)g(t) = \int_{ - \infty }^{ + \infty } {f(\tau )g(t - \tau )d\tau }\]</span></p></li><li><p>相关： <span class="math display">\[{R_{fg} }(t) = \int_{ - \infty }^{ + \infty } {f(\tau ){g^*}(t - \tau)d\tau }\]</span></p></li></ul><p><strong>符号表示</strong></p><p><img src="https://s2.loli.net/2022/02/14/xdoG4UDPLBYV8ta.png" /></p><h3 id="信号操作">1.5.2信号操作</h3><p>1）自变量操作：倍乘、移位、反褶、尺度</p><p><img src="https://s2.loli.net/2022/02/14/NOIP4iGk2qps5Yt.png" /></p><p>2）信号的微分：突出了信号的变化部分，提升了高频</p><p>3）信号的积分：突出了信号的平滑部分，提升了低频</p><p>4）信号的相加（信号的分解与组合）</p><p>5）信号的相乘（信号幅度调制）</p><p>6）信号的卷积、相关</p><h2 id="信号的分解">1.6信号的分解</h2><h3 id="信号的直交分解">1.6.1信号的直交分解</h3><p>直流分量：信号的均值，是一个常量。</p><p>交流分量：减去直流分量，交流分量的积分为零。</p><p>直交分解的正交关系： <span class="math display">\[\int_{ - \frac{T}{2} }^{\frac{T}{2} } { {f_D}(t){f_A}(t)dt}  =\left\langle { {f_D},{f_A} } \right\rangle  = {f_D}\int_{ - \frac{T}{2}}^{\frac{T}{2} } { {f_A}(t)dt}  = 0\]</span> 能量守恒(Parsavel定理)： <span class="math display">\[E = {E_D} + {E_A}\]</span></p><h3 id="信号的奇偶分解">1.6.2信号的奇偶分解</h3><p>任何信号都可以分解成一个奇分量和偶分量的叠加： <spanclass="math display">\[\begin{array}{l}f(t) = {f_e}(t) + {f_o}(t)\quad \quad \;\;\,(1)\\f( - t) = {f_e}(t) - {f_o}(t)\quad \quad (2)\end{array}\]</span> 奇偶分解的正交关系： <span class="math display">\[\int_{ - \infty }^\infty  { {f_e}(t){f_o}(t)dt}  = \frac{1}{4}\int_{ -\infty }^\infty  {[{f^2}(t) - {f^2}( - t)]dt}  = 0\]</span> 能量守恒： <span class="math display">\[E = {E_e} + {E_o}\]</span></p><h3 id="信号的实部虚部分解">1.6.3信号的实部虚部分解</h3><p><span class="math display">\[\begin{array}{*{20}{l} }{f(t) = {f_R}(t) + j{f_I}(t)\quad \quad \;\;{\mkern 1mu} (1)}\\{ {f^*}(t) = {f_R}(t) - j{f_I}(t)\quad \quad (2)}\end{array}\]</span></p><p>模与幅度：（能量守恒） <span class="math display">\[\begin{array}{l}{\left| {f(t)} \right|^2} = f_R^2(t) + f_I^2(t)\quad \quad {\left|{f(t)} \right|^2} = f(t){f^*}(t)\\\theta  = t{g^{ - 1} }(\frac{ { {f_I} } }{ { {f_R} } })\end{array}\]</span> <imgsrc="https://s2.loli.net/2022/02/15/wP4opWvQZtFYS9q.png" /></p><h3 id="信号的脉冲分解">1.6.4信号的脉冲分解</h3><p>离散时间信号的脉冲分解： <span class="math display">\[x[n] = \sum\limits_{k =  - \infty }^\infty  {x[k]\delta [n - k]}\]</span> 连续时间信号的脉冲分解： <span class="math display">\[f({t_1}) = \int_{ - \infty }^\infty  {f(t)\delta (t - {t_1})dt}\]</span> 脉冲信号的分量具有正交关系。</p>]]></content>
    
    
    <categories>
      
      <category>复试学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux和Windows安装tensorflow-cpu 2.x</title>
    <link href="/2022/03/10/Linux%E5%92%8CWindows%E5%AE%89%E8%A3%85tensorflow-cpu/"/>
    <url>/2022/03/10/Linux%E5%92%8CWindows%E5%AE%89%E8%A3%85tensorflow-cpu/</url>
    
    <content type="html"><![CDATA[<h1id="linux和windows安装tensorflow-cpu-2.x">Linux和Windows安装tensorflow-cpu2.x</h1><p>网络上有许多安装tensorflow的教程，我写这篇博客主要是想记录下自己安装tensorflow过程中踩的坑，现在回过头看tensorflow的安装其实无比简单。在这里将我的经验写下来，供大家借鉴参考，linux和Windows同样适用。<span id="more"></span>在初次安装tensorflow时，网络上的许多教程都讲可以通过anaconda进行安装。按照教程的步骤，首先是使用conda创建一个新的虚拟环境，对于刚刚接触的我来说并不明白虚拟环境是什么意思，所以就导致了我即使是成功安装了tensorflow而不自知。</p><p>下面我将自己的安装步骤详细记录下来，并对一些问题进行解释。</p><h2 id="一anaconda的安装">一、anaconda的安装</h2><p>不同的项目用到的环境可能不一样，但有些环境在同一台计算机里面可能会导致冲突，这就是为什么有时候会产生一些莫名其妙错误的原因，所以我们希望将这些环境隔离开来。anaconda就是这样一个很好的工具。</p><p><img src="https://s2.loli.net/2022/02/12/x3r4PSn582wmUoc.png" /></p><p><a href="https://www.anaconda.com/products/individual">Anaconda |Individual Edition</a></p><p>从这个网站上下载，根据自己的操作系统选择相应的版本，可以直接使用最新版本。</p><p>Windows是寻常的.exe文件，按照提示进行安装；Linux是.sh文件，在shell终端使用sh文件名.sh安装。Linux操作系统下需要注意更改安装路径，建议放在用户目录下，这样可以避免后续安装过程中始终被要求获得root权限。具体安装步骤这里不详加叙述，安装成功并添加好环境变量后，可以使用conda-V命令验证。</p><h2 id="二虚拟环境的创建">二、虚拟环境的创建</h2><p>顺利安装anaconda后，在命令行终端输入</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda create -n tensorflow python&#x3D;3.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>创建一个虚拟环境，python=3.9是指定在虚拟环境安装python3.9</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda info -e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>查看已安装的环境。</p><p><img src="https://s2.loli.net/2022/02/12/FJQjiU9l3hZDdMb.png" /></p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">activate tensorflow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>切换虚拟环境（deactivate退出当前环境）。</p><p><img src="https://s2.loli.net/2022/02/12/3GpnKfa29PFiv14.png" /></p><p>后续在“tensorflow”这个虚拟环境中安装的任何库，均仅在此虚拟环境中生效。</p><h2 id="三tensorflow安装">三、tensorflow安装</h2><p>tensorflow分为cpu和gpu两个版本。gpu需要计算机有英伟达的显卡，我将在下面一篇博客中介绍如何安装和配置环境。</p><p><ahref="https://2022xi.github.io/2022/02/12/在公共Linux服务器上使用非root用户离线安装tensorflow-gpu/">在公共服务器上使用非root用户离线安装tensorflow-gpu2.x - 舍功利之心，注一腔热情。 (2022xi.github.io)</a></p><p>进入虚拟环境后，在命令行终端输入</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda install tensorflow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>等待自动安装一些依赖。</p><p>安装完成后，我们来验证一下。</p><div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>进入python环境</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tfa <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>成功安装输出结果</p><p><img src="https://s2.loli.net/2022/02/12/tcLQ4g2RzJIkMSv.png" /></p><p>不想让中间警告信息显示时，可以通过添加如下两行代码，设置TensorFlow日志输出级别。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">impot osos<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"TF_CPP_MIN_LOG_LEVEL"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"3"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>到这里tensorflow的安装就完成了，需要注意在使用时激活虚拟环境。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>tensorflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
